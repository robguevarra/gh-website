# Task ID: 20
# Title: User Tagging and Segmentation System
# Status: cancelled
# Dependencies: 17
# Priority: medium
# Description: Implement a tagging system for categorizing users and create predefined segments for common user groups to enable targeted email communications.
# Details:
1. Design database schema for user tags and segments
2. Create API endpoints for tag management
3. Implement tag assignment logic for users
4. Develop predefined segments based on common criteria:
   - Enrollment status
   - Purchase history
   - Activity level
   - Content preferences
5. Build filtering logic for combining tags and other user attributes
6. Create segment preview and size estimation tools
7. Implement batch operations for tag management

```sql
-- Example schema for tags and segments

-- Tags table
CREATE TABLE user_tags (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User-tag association table
CREATE TABLE user_tag_assignments (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (user_id, tag_id)
);

-- Segments table
CREATE TABLE user_segments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  filter_criteria JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Example filter criteria JSON structure:
-- {
--   "operator": "AND",
--   "conditions": [
--     { "type": "tag", "operator": "has", "value": "tag_id_1" },
--     { "type": "tag", "operator": "not_has", "value": "tag_id_2" },
--     { "type": "profile", "field": "enrollment_status", "operator": "equals", "value": "active" },
--     { "type": "activity", "operator": "last_active", "value": "30d" }
--   ]
-- }
```

```typescript
// Example segment evaluation function
async function evaluateSegment(segmentId: string): Promise<string[]> {
  // Fetch segment definition
  const { data: segment } = await supabase
    .from('user_segments')
    .select('*')
    .eq('id', segmentId)
    .single();
    
  if (!segment) throw new Error('Segment not found');
  
  // Build SQL query based on filter criteria
  let query = supabase.from('users').select('id');
  
  // Apply filters based on segment.filter_criteria
  // This is a simplified example - real implementation would be more complex
  const criteria = segment.filter_criteria;
  
  if (criteria.operator === 'AND') {
    for (const condition of criteria.conditions) {
      if (condition.type === 'tag' && condition.operator === 'has') {
        query = query.in('id', (sb) => 
          sb.from('user_tag_assignments')
            .select('user_id')
            .eq('tag_id', condition.value)
        );
      }
      // Add other condition types...
    }
  }
  
  // Execute query and return user IDs
  const { data: users, error } = await query;
  
  if (error) throw error;
  return users.map(user => user.id);
}
```

# Test Strategy:
1. Unit test tag assignment and removal functionality
2. Test segment evaluation with various filter criteria
3. Benchmark performance with large user datasets
4. Verify segment size estimation accuracy
5. Test batch operations with different tag combinations
6. Validate database integrity with concurrent operations
