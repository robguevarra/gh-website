{
  "tasks": [
    {
      "id": 1,
      "title": "Audit and Document Existing User Data Schema",
      "description": "Review all existing user-related tables, relationships, and data structures to identify gaps and requirements for the admin system.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Analyze the current Supabase database schema focusing on unified_profiles, enrollments, shopify_orders, shopify_order_items, and related tables. Document the current state, identify missing fields needed for admin functionality, and create an ERD (Entity Relationship Diagram) showing all relationships. Pay special attention to how user data is currently structured and where administrative metadata is stored. The schema enhancements have been implemented in the database using Supabase migrations, including administrative fields in unified_profiles, tables for user notes, admin audit logging, and user activity tracking, search optimization with trigram indexes, a unified purchase history view, and helper functions for admin operations. The documentation has been created in ProjectDocs/admin-user-schema-audit.md.",
      "testStrategy": "Produce comprehensive documentation including current schema diagrams, identified gaps, and implemented changes. Review with stakeholders to ensure all requirements are captured and properly implemented.",
      "subtasks": [
        {
          "id": 1,
          "title": "Extract and Document Current User-Related Tables Schema",
          "description": "Extract the complete schema definition for all user-related tables from Supabase, including unified_profiles, enrollments, shopify_orders, shopify_order_items, and document their current structure.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Connect to the Supabase database using appropriate credentials\n2. Use SQL information_schema queries to extract table definitions, columns, data types, constraints, and indexes for the primary user-related tables\n3. Document each table's purpose, primary keys, foreign keys, and unique constraints\n4. Create a comprehensive data dictionary listing all fields with their data types, constraints, and business purpose\n5. Identify which fields store user identity information, contact details, and administrative metadata\n6. Document any existing triggers or functions that modify these tables\n\nTesting approach:\n- Verify the extracted schema matches the actual database structure\n- Cross-check documentation against sample data to ensure all fields are properly documented",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Document Views and Functions Related to User Data",
          "description": "Analyze and document all views, functions, and triggers that interact with user data, focusing on monthly_enrollments_view, revenue_analysis_view, marketing_source_view, unified purchase history view, and related functions/triggers, including the newly implemented admin helper functions.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Extract the definitions of all views that present or transform user data, including the new unified purchase history view\n2. Document each view's purpose, source tables, and transformation logic\n3. Extract and document all functions and stored procedures that modify or access user data, including the newly implemented admin helper functions\n4. Document triggers that affect user-related tables, including any new ones for admin audit logging\n5. Create a dependency map showing how views and functions relate to the base tables\n6. Identify which views and functions would need to be updated if the schema changes further\n7. Update the ProjectDocs/admin-user-schema-audit.md with the views and functions documentation\n\nTesting approach:\n- Verify all views can be successfully queried\n- Confirm function documentation matches actual behavior by testing with sample inputs\n- Validate that all newly implemented admin helper functions are properly documented",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Map Entity Relationships and Create ERD",
          "description": "Create a comprehensive Entity Relationship Diagram (ERD) showing all user-related tables, their relationships, cardinality, and how they connect to other parts of the system, including the newly added tables for user notes, admin audit logging, and user activity tracking.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Use a database modeling tool (e.g., dbdiagram.io, Lucidchart, or similar) to create the ERD\n2. Include all user-related tables documented in subtask 1\n3. Add the newly implemented tables for user notes, admin audit logging, and user activity tracking\n4. Map all relationships between tables, showing primary and foreign keys\n5. Document cardinality of relationships (one-to-one, one-to-many, many-to-many)\n6. Include views from subtask 2 in the diagram, showing their data sources\n7. Color-code or group tables by functional area (user identity, transactions, enrollments, admin functionality, etc.)\n8. Export the ERD in both editable format and as a PNG/PDF for documentation\n9. Update the ProjectDocs/admin-user-schema-audit.md with the ERD\n\nTesting approach:\n- Verify all tables from subtask 1 and newly implemented tables are included in the ERD\n- Confirm all relationships are correctly represented\n- Have another team member review the ERD for accuracy and completeness",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Identify Schema Gaps for Admin Functionality",
          "description": "Analyze the current schema to identify missing fields, tables, or relationships needed to support administrative functionality, focusing on user management, permissions, and audit trails.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Review common administrative requirements: user roles, permissions, status flags, audit trails, etc.\n2. Compare these requirements against the current schema to identify gaps\n3. Document missing fields needed in existing tables (e.g., is_admin, role_id, status)\n4. Identify new tables that may be needed (e.g., roles, permissions, admin_logs)\n5. Document missing relationships between existing and potentially new tables\n6. Prioritize the identified gaps based on importance for admin functionality\n7. Consider data migration implications for any proposed changes\n\nTesting approach:\n- Create user stories for admin functionality and verify the identified schema can support them\n- Review findings with stakeholders to validate the completeness of the gap analysis",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Create Schema Enhancement Recommendations Document",
          "description": "Compile a comprehensive recommendations document that outlines proposed schema changes, additions, and modifications needed to support the admin system.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Compile findings from all previous subtasks into a cohesive document\n2. Create SQL scripts for recommended schema changes (new tables, altered tables, new fields)\n3. Document potential impacts of schema changes on existing functionality\n4. Provide recommendations for handling data migration for any schema changes\n5. Include the ERD from subtask 3 with annotations showing proposed changes\n6. Document recommended changes to views and functions based on schema modifications\n7. Include a section on security considerations for admin data\n8. Create an implementation timeline and dependency chart for the recommended changes\n\nTesting approach:\n- Review recommendations with database administrators and developers\n- Validate that all identified gaps from subtask 4 are addressed\n- Test proposed SQL scripts in a development environment to verify syntax and functionality",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 6,
          "title": "Document Implemented Schema Enhancements",
          "description": "Document the schema enhancements that have been implemented in the database using Supabase migrations.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implementation steps:\n1. Document the administrative fields added to unified_profiles\n2. Document the new tables created for user notes, admin audit logging, and user activity tracking\n3. Document the search optimization implemented with trigram indexes\n4. Document the unified purchase history view\n5. Document the helper functions implemented for admin operations\n6. Update the ProjectDocs/admin-user-schema-audit.md with the implemented enhancements\n7. Create a section comparing the recommended changes with what was actually implemented\n8. Document any deviations from the original recommendations and the rationale behind them\n\nTesting approach:\n- Verify that all implemented changes are properly documented\n- Confirm that the documentation accurately reflects the current state of the database\n- Review the documentation with stakeholders to ensure clarity and completeness",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Enhance Data Model with Admin-Required Fields",
      "description": "Implement additional tables and fields required for administrative functionality based on the audit findings.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create migration scripts for Supabase to add: 1) admin_audit_log table for tracking administrative actions, 2) user_notes table for administrative annotations, 3) additional fields to unified_profiles for admin-specific flags and metadata. Implement proper foreign key relationships and indexes for performance. Create TypeScript interfaces for all enhanced data models to ensure type safety throughout the application.",
      "testStrategy": "Execute migrations in development environment, verify table structure matches design, and test basic CRUD operations on new tables. Create sample data to validate relationships."
    },
    {
      "id": 3,
      "title": "Develop Data Access Layer for Admin Operations",
      "description": "Create server-side functions and optimized SQL queries for common administrative data operations.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Implement a set of TypeScript functions that handle data access for admin operations including: 1) paginated user queries with filtering, 2) detailed user profile retrieval with related data, 3) audit logging functions, 4) user update operations. Use Supabase client with proper error handling and optimize queries for performance. Implement caching strategies where appropriate for frequently accessed data.",
      "testStrategy": "Create unit tests for each data access function, testing both success paths and error handling. Benchmark query performance against requirements (2-3 second load times)."
    },
    {
      "id": 4,
      "title": "Create Basic Admin Layout and Navigation",
      "description": "Implement the admin interface layout, navigation structure, and authentication guards.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create a layout component for the admin area at /admin using Next.js App Router. Implement navigation sidebar with links to users and future admin sections. Add authentication middleware to protect all admin routes, ensuring only users with admin role can access these pages. Use Shadcn UI components for consistent styling and implement responsive design that works across all device sizes.",
      "testStrategy": "Test authentication guards by attempting access with different user roles. Verify responsive behavior across multiple device sizes. Ensure keyboard navigation and screen reader accessibility."
    },
    {
      "id": 5,
      "title": "Implement User List View with Pagination",
      "description": "Create the responsive data table at /admin/users with basic pagination functionality.",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "high",
      "details": "Most of the implementation for the /admin/users page has been completed, including:\n\n1. A server component that fetches paginated user data using our data access layer\n2. A responsive data table using Shadcn UI components showing key user information\n3. Advanced filtering capabilities (status, acquisition source, transaction history, date ranges)\n4. Pagination controls with URL parameter state persistence\n5. Loading states and error handling\n6. Quick action buttons for viewing and editing user details\n\nRemaining work focuses on performance optimization and responsive testing to ensure the implementation meets requirements across all device sizes.",
      "testStrategy": "Verify that the implementation meets the 2-second initial load requirement across various network conditions. Test pagination with different page sizes to ensure consistent performance. Validate responsive behavior across device sizes (mobile, tablet, desktop) to confirm usability on all screen dimensions. Verify that all implemented features (filtering, sorting, pagination, quick actions) work correctly across devices.",
      "subtasks": [
        {
          "id": "5.1",
          "title": "Performance optimization",
          "description": "Analyze and optimize the current implementation to ensure it meets the 2-second initial load requirement. This may include implementing data caching strategies, optimizing database queries, or adding virtualization for large data sets.",
          "status": "done"
        },
        {
          "id": "5.2",
          "title": "Cross-device responsive testing",
          "description": "Test the user list view across multiple device sizes (mobile, tablet, desktop) to ensure the responsive design works correctly. Verify that all functionality remains accessible and usable regardless of screen size.",
          "status": "done"
        },
        {
          "id": "5.3",
          "title": "Performance testing documentation",
          "description": "Document performance test results showing that the implementation meets the 2-second initial load requirement under various conditions (different page sizes, filter combinations, etc.).",
          "status": "done"
        }
      ]
    },
    {
      "id": 6,
      "title": "Add Search, Filtering and Sorting to User List",
      "description": "Enhance the user list with robust search capabilities, advanced filtering, and column sorting.",
      "status": "in-progress",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "The user list has been enhanced with column sorting functionality and improved filtering UI. Completed work includes: (1) Column sorting with visual indicators for sort direction and URL parameter reflection, (2) Enhanced filtering UI with toggle functionality and fixed parameter/TypeScript issues, (3) Improved UX with cleaner UI and responsive design. Next steps include implementing advanced search functionality with typeahead suggestions and field-specific search capabilities. All implementations follow Next.js best practices with proper separation of client and server components.",
      "testStrategy": "Test search with partial matches and special characters. Verify all filters work correctly in combination. Test sorting on different columns and ensure visual indicators match the current sort state. Ensure URL parameters correctly reflect all filter and sort states. Test responsive design across various screen sizes.",
      "subtasks": [
        {
          "id": "6.1",
          "title": "Implement column sorting functionality",
          "status": "done",
          "description": "Added sort functionality to all relevant columns in the user table with visual indicators (arrows) for sort direction. Ensured sort state is reflected in URL parameters."
        },
        {
          "id": "6.2",
          "title": "Enhance filtering UI",
          "status": "done",
          "description": "Added a toggle button to show/hide filters. Fixed parameter name issues in the filter component and TypeScript errors with the date picker components."
        },
        {
          "id": "6.3",
          "title": "Improve user experience",
          "status": "done",
          "description": "Removed duplicate search functionality for a cleaner UI. Ensured responsive design for all screen sizes. Fixed build errors by properly separating client and server components."
        },
        {
          "id": "6.4",
          "title": "Implement advanced search functionality",
          "status": "todo",
          "description": "Add typeahead suggestions to the search input to help users find what they're looking for more quickly. Implement field-specific search capabilities allowing users to search by specific attributes."
        },
        {
          "id": "6.5",
          "title": "Conduct comprehensive testing",
          "status": "todo",
          "description": "Test all implemented features in combination, including sorting, filtering, and search. Verify URL parameters correctly reflect all states and can be shared. Test across different browsers and screen sizes."
        }
      ]
    },
    {
      "id": 7,
      "title": "Create User Detail View Framework",
      "description": "Build the basic structure for the comprehensive user profile at /admin/users/[id].",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "high",
      "details": "Implement the user detail page at /admin/users/[id] with a tabbed interface using Shadcn UI tabs component. Create the basic layout with sections for personal details, purchase history, enrollments, and activity tracking. Fetch core user data and implement navigation between tabs that preserves state. Add breadcrumb navigation back to the user list and implement proper loading and error states.",
      "testStrategy": "Test navigation between tabs, verify data loading for different user IDs, and ensure the UI matches design specifications. Test error handling with invalid user IDs."
    },
    {
      "id": 8,
      "title": "Implement User Profile and Editing Functionality",
      "description": "Complete the personal details tab with editable fields and validation.",
      "status": "done",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Enhance the personal details tab with all user profile information. Implement editable fields using Shadcn UI form components with client-side validation. Create server actions for securely updating user data with proper error handling. Add confirmation workflows for sensitive changes and implement optimistic updates for better UX. Ensure all edits are logged to the admin_audit_log table.",
      "testStrategy": "Test form validation with valid and invalid inputs. Verify server actions correctly update the database. Test audit logging for all edit operations. Ensure error messages are clear and helpful."
    },
    {
      "id": 9,
      "title": "Develop Purchase History and Enrollment Sections",
      "description": "Implement the purchase history and enrollment tabs in the user detail view.",
      "status": "done",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Create the purchase history tab showing all transactions from shopify_orders and shopify_order_items with product details and payment information. Implement the enrollment tab displaying current and past course enrollments with status indicators. Add filtering and sorting capabilities within each tab. Include action buttons for managing enrollments and viewing order details. Ensure efficient data loading with pagination for users with extensive history.",
      "testStrategy": "Test with users having various purchase and enrollment patterns. Verify all data is displayed correctly and actions work as expected. Test pagination for users with large datasets."
    },
    {
      "id": 10,
      "title": "Create Activity and Engagement Tracking",
      "description": "Implement the activity tracking tab with login history and content access statistics.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "low",
      "details": "Develop the activity tracking tab showing login history, content access patterns, and engagement metrics. Create visualizations using a charting library to display trends over time. Implement filtering by date ranges and activity types. Add export functionality for activity data. Ensure efficient data loading and aggregation for users with extensive activity history.",
      "testStrategy": "Test with users having various activity patterns. Verify visualizations render correctly and are responsive. Test date filtering and exports for accuracy."
    },
    {
      "id": 11,
      "title": "Implement Administrative Tools and Access Management",
      "description": "Build administrative tooling including password reset, account status management, and access controls.",
      "status": "done",
      "dependencies": [
        8
      ],
      "priority": "high",
      "details": "Create an administrative tools tab with functionality for password reset, account status changes (active/inactive/suspended), and feature access management. Implement secure server actions for these operations with appropriate confirmation workflows. Add detailed logging to admin_audit_log for all administrative actions. Include email notification options for relevant actions (e.g., password reset).",
      "testStrategy": "Test each administrative action for proper execution and audit logging. Verify confirmation workflows prevent accidental changes. Test email notifications if implemented."
    },
    {
      "id": 12,
      "title": "Develop Account Reconciliation Interface",
      "description": "Create the interface for searching and linking user records across different systems.",
      "status": "done",
      "dependencies": [
        8
      ],
      "priority": "medium",
      "details": "Implement an account reconciliation tab that allows searching for potentially related user accounts across systems. Create UI for manually linking accounts with confirmation workflow. Develop data comparison views to help identify matching accounts. Implement merge functionality with clear preview of results and conflict resolution. Ensure all reconciliation actions are logged for audit purposes.",
      "testStrategy": "Test search functionality with various criteria. Verify linking and merging operations maintain data integrity. Test conflict resolution scenarios and ensure audit logging captures all actions."
    },
    {
      "id": 13,
      "title": "Create User Analytics Dashboard",
      "description": "Design and implement the user analytics dashboard showing acquisition trends and engagement metrics.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "low",
      "details": "Develop a user analytics dashboard at /admin/analytics with visualizations for user acquisition trends, engagement metrics, and cohort analysis. Implement filtering by date ranges and user segments. Create summary cards for key metrics and detailed charts for trends. Use a charting library compatible with Next.js and ensure responsive design for all visualizations.",
      "testStrategy": "Test dashboard with various date ranges and user segments. Verify all visualizations render correctly and are responsive. Benchmark performance against requirements."
    },
    {
      "id": 14,
      "title": "Implement Reporting and Export Functionality",
      "description": "Build reporting capabilities and data export functionality in common formats.",
      "status": "pending",
      "dependencies": [
        13
      ],
      "priority": "low",
      "details": "Add export functionality to the analytics dashboard and user list for common formats (CSV, Excel). Implement custom report generation with selectable fields and filtering criteria. Create scheduled report functionality with email delivery options. Ensure exports include proper headers and formatting for readability. Add progress indicators for large exports.",
      "testStrategy": "Test exports in different formats for accuracy and formatting. Verify custom reports generate correctly with various criteria. Test scheduled reports if implemented."
    },
    {
      "id": 15,
      "title": "Implement Security Enhancements and Final Testing",
      "description": "Add security features, conduct comprehensive testing, and prepare for deployment.",
      "status": "in-progress",
      "dependencies": [
        11,
        12,
        14
      ],
      "priority": "high",
      "details": "Implement role-based access control for different administrative functions. Add rate limiting for sensitive operations. Conduct security review of all admin endpoints. Implement comprehensive error handling and logging. Perform end-to-end testing of all user flows. Optimize performance for any slow operations identified during testing. Create documentation for administrators using the system.",
      "testStrategy": "Conduct penetration testing focusing on admin functions. Verify all user flows work end-to-end. Test error scenarios and recovery. Measure performance against requirements and optimize as needed."
    },
    {
      "id": 16,
      "title": "Postmark Account Setup and Configuration",
      "description": "Create and configure Postmark account with proper authentication settings for the Graceful Homeschooling platform.",
      "details": "1. Sign up for a Postmark account\n2. Configure sender signatures for all required domains\n3. Verify domain ownership through DNS records\n4. Set up SPF, DKIM, and DMARC records for improved deliverability\n5. Create server instances for different environments (development, staging, production)\n6. Generate and securely store API tokens\n7. Configure initial bounce handling and webhook endpoints\n8. Set up message streams for different email types (transactional, marketing, etc.)\n9. Test basic connectivity with Postmark API",
      "testStrategy": "1. Verify domain authentication status in Postmark dashboard\n2. Confirm SPF, DKIM, and DMARC records are properly configured using DNS lookup tools\n3. Send test emails through Postmark API to verify connectivity\n4. Validate webhook endpoints are properly receiving test events",
      "priority": "high",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Postmark API Client Implementation",
      "description": "Develop a reusable API client for interacting with Postmark services, including error handling and logging.",
      "details": "1. Create a PostmarkService class that encapsulates all Postmark API interactions\n2. Implement methods for sending transactional emails\n3. Implement methods for sending batch emails\n4. Implement methods for template management\n5. Add robust error handling with appropriate retry logic\n6. Implement logging for all API interactions\n7. Create environment-specific configurations\n8. Add rate limiting protection\n9. Implement helper methods for common email operations\n\n```typescript\n// Example PostmarkService implementation\nclass PostmarkService {\n  private client: PostmarkClient;\n  \n  constructor(apiKey: string) {\n    this.client = new PostmarkClient(apiKey);\n  }\n  \n  async sendTransactionalEmail(options: EmailOptions): Promise<SendResult> {\n    try {\n      const response = await this.client.sendEmail({\n        From: options.from,\n        To: options.to,\n        Subject: options.subject,\n        HtmlBody: options.htmlBody,\n        TextBody: options.textBody,\n        MessageStream: 'outbound',\n        // Additional options as needed\n      });\n      \n      logger.info('Email sent successfully', { messageId: response.MessageID });\n      return { success: true, messageId: response.MessageID };\n    } catch (error) {\n      logger.error('Failed to send email', { error, options });\n      // Implement retry logic if appropriate\n      return { success: false, error };\n    }\n  }\n  \n  // Additional methods for other Postmark operations\n}\n```",
      "testStrategy": "1. Write unit tests for each API client method using mocked Postmark responses\n2. Test error handling with simulated API failures\n3. Verify logging captures appropriate information\n4. Test retry logic with forced failures\n5. Create integration tests that send actual emails to test accounts\n6. Verify rate limiting behavior works as expected",
      "priority": "high",
      "dependencies": [
        16
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "MJML Email Template System",
      "description": "Implement MJML processing for responsive email design and create base templates following Graceful Homeschooling design guidelines.",
      "details": "1. Install and configure MJML processing libraries\n2. Create base MJML template with Graceful Homeschooling branding (Purple #b08ba5, Pink #f1b5bc, Blue #9ac5d9)\n3. Implement typography standards (Inter for body text, Playfair Display for headings)\n4. Design responsive layouts that work across all email clients\n5. Create component library for common email elements (headers, footers, buttons, etc.)\n6. Implement variable substitution system for personalization\n7. Create utility functions to convert MJML to HTML\n8. Set up template storage in the database\n\n```typescript\n// Example MJML template processing\nimport mjml2html from 'mjml';\n\nconst baseTemplate = `\n<mjml>\n  <mj-head>\n    <mj-attributes>\n      <mj-all font-family=\"Inter, Arial, sans-serif\" />\n      <mj-text font-weight=\"400\" font-size=\"16px\" color=\"#000000\" line-height=\"24px\" />\n      <mj-section padding=\"0px\" />\n    </mj-attributes>\n    <mj-style>\n      h1, h2, h3, h4 { font-family: 'Playfair Display', Georgia, serif; }\n      .gh-primary { color: #b08ba5; }\n      .gh-secondary { color: #f1b5bc; }\n      .gh-tertiary { color: #9ac5d9; }\n    </mj-style>\n  </mj-head>\n  <mj-body background-color=\"#ffffff\">\n    <!-- Header -->\n    <mj-section background-color=\"#b08ba5\" padding=\"20px\">\n      <mj-column>\n        <mj-image width=\"200px\" src=\"{{logoUrl}}\" alt=\"Graceful Homeschooling\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Content -->\n    <mj-section padding=\"20px\">\n      <mj-column>\n        <mj-text>\n          {{content}}\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Footer -->\n    <mj-section background-color=\"#f6f6f6\" padding=\"20px\">\n      <mj-column>\n        <mj-text align=\"center\" font-size=\"12px\">\n          &copy; {{year}} Graceful Homeschooling. All rights reserved.\n          <br />\n          {{#if showUnsubscribe}}\n          <a href=\"{{unsubscribeUrl}}\">Unsubscribe</a>\n          {{/if}}\n        </mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n`;\n\nfunction renderTemplate(template, variables) {\n  // Replace variables in template\n  const processedTemplate = Object.entries(variables).reduce(\n    (result, [key, value]) => result.replace(new RegExp(`{{${key}}}`, 'g'), value),\n    template\n  );\n  \n  // Convert MJML to HTML\n  const { html, errors } = mjml2html(processedTemplate);\n  \n  if (errors && errors.length) {\n    console.error('MJML processing errors:', errors);\n  }\n  \n  return html;\n}\n```",
      "testStrategy": "1. Create visual regression tests for email templates\n2. Test templates across different email clients using Email on Acid or Litmus\n3. Verify responsive behavior on mobile, tablet, and desktop viewports\n4. Test variable substitution with different data sets\n5. Validate HTML output meets email client compatibility standards\n6. Test rendering performance with large templates",
      "priority": "high",
      "dependencies": [
        16
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Supabase Auth Integration with Postmark",
      "description": "Configure Supabase to use Postmark for authentication emails and customize templates for email confirmation, password reset, and magic links.",
      "details": "1. Update Supabase configuration to use Postmark as the email provider\n2. Create custom email templates for:\n   - Email confirmation\n   - Password reset\n   - Magic link authentication\n3. Implement secure credential management to replace \"graceful2025\" default pattern\n4. Configure email sender identity for authentication emails\n5. Set up proper redirect URLs for authentication flows\n6. Implement custom handlers for authentication events\n7. Add logging for authentication email events\n\n```typescript\n// Example Supabase configuration for Postmark\nimport { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Client for public operations\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Admin client for server-side operations\nexport const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);\n\n// Configure email templates via Supabase dashboard or API\nasync function configureAuthEmailTemplates() {\n  // This would typically be done through the Supabase dashboard\n  // or using their management API\n  \n  // Example of how to update auth email templates programmatically\n  // (if supported by Supabase API)\n  await supabaseAdmin.auth.updateConfig({\n    email_templates: {\n      invite: {\n        subject: 'Join Graceful Homeschooling',\n        content: '...' // MJML template converted to HTML\n      },\n      confirmation: {\n        subject: 'Confirm Your Graceful Homeschooling Account',\n        content: '...' // MJML template converted to HTML\n      },\n      recovery: {\n        subject: 'Reset Your Graceful Homeschooling Password',\n        content: '...' // MJML template converted to HTML\n      },\n      magic_link: {\n        subject: 'Your Magic Link to Graceful Homeschooling',\n        content: '...' // MJML template converted to HTML\n      }\n    }\n  });\n}\n```",
      "testStrategy": "1. Test complete authentication flows (registration, password reset, magic link)\n2. Verify emails are sent through Postmark with correct templates\n3. Test email deliverability to various email providers\n4. Validate all links in authentication emails work correctly\n5. Test secure credential management with various password patterns\n6. Verify proper error handling for authentication failures",
      "priority": "high",
      "dependencies": [
        17,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "User Tagging and Segmentation System",
      "description": "Implement a tagging system for categorizing users and create predefined segments for common user groups to enable targeted email communications.",
      "details": "1. Design database schema for user tags and segments\n2. Create API endpoints for tag management\n3. Implement tag assignment logic for users\n4. Develop predefined segments based on common criteria:\n   - Enrollment status\n   - Purchase history\n   - Activity level\n   - Content preferences\n5. Build filtering logic for combining tags and other user attributes\n6. Create segment preview and size estimation tools\n7. Implement batch operations for tag management\n\n```sql\n-- Example schema for tags and segments\n\n-- Tags table\nCREATE TABLE user_tags (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- User-tag association table\nCREATE TABLE user_tag_assignments (\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,\n  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  PRIMARY KEY (user_id, tag_id)\n);\n\n-- Segments table\nCREATE TABLE user_segments (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  filter_criteria JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Example filter criteria JSON structure:\n-- {\n--   \"operator\": \"AND\",\n--   \"conditions\": [\n--     { \"type\": \"tag\", \"operator\": \"has\", \"value\": \"tag_id_1\" },\n--     { \"type\": \"tag\", \"operator\": \"not_has\", \"value\": \"tag_id_2\" },\n--     { \"type\": \"profile\", \"field\": \"enrollment_status\", \"operator\": \"equals\", \"value\": \"active\" },\n--     { \"type\": \"activity\", \"operator\": \"last_active\", \"value\": \"30d\" }\n--   ]\n-- }\n```\n\n```typescript\n// Example segment evaluation function\nasync function evaluateSegment(segmentId: string): Promise<string[]> {\n  // Fetch segment definition\n  const { data: segment } = await supabase\n    .from('user_segments')\n    .select('*')\n    .eq('id', segmentId)\n    .single();\n    \n  if (!segment) throw new Error('Segment not found');\n  \n  // Build SQL query based on filter criteria\n  let query = supabase.from('users').select('id');\n  \n  // Apply filters based on segment.filter_criteria\n  // This is a simplified example - real implementation would be more complex\n  const criteria = segment.filter_criteria;\n  \n  if (criteria.operator === 'AND') {\n    for (const condition of criteria.conditions) {\n      if (condition.type === 'tag' && condition.operator === 'has') {\n        query = query.in('id', (sb) => \n          sb.from('user_tag_assignments')\n            .select('user_id')\n            .eq('tag_id', condition.value)\n        );\n      }\n      // Add other condition types...\n    }\n  }\n  \n  // Execute query and return user IDs\n  const { data: users, error } = await query;\n  \n  if (error) throw error;\n  return users.map(user => user.id);\n}\n```",
      "testStrategy": "1. Unit test tag assignment and removal functionality\n2. Test segment evaluation with various filter criteria\n3. Benchmark performance with large user datasets\n4. Verify segment size estimation accuracy\n5. Test batch operations with different tag combinations\n6. Validate database integrity with concurrent operations",
      "priority": "medium",
      "dependencies": [
        17
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Email Template Management Interface",
      "description": "Create an admin interface for managing email templates, including a visual editor for non-technical staff to create and edit templates.",
      "details": "1. Design template management UI with listing, search, and filtering\n2. Implement template creation workflow\n3. Create visual WYSIWYG editor for template editing\n4. Add MJML code editor for advanced users\n5. Implement template versioning and history\n6. Add template preview functionality\n7. Create template categories for organization\n8. Implement template duplication and templating\n9. Add variable management for personalization\n\n```typescript\n// Example template editor component\nimport React, { useState, useEffect } from 'react';\nimport { Editor } from 'some-wysiwyg-editor';\nimport { supabase } from '../lib/supabaseClient';\nimport { convertToMjml, renderMjmlPreview } from '../lib/emailUtils';\n\nconst TemplateEditor = ({ templateId, onSave }) => {\n  const [template, setTemplate] = useState(null);\n  const [content, setContent] = useState('');\n  const [previewHtml, setPreviewHtml] = useState('');\n  const [saving, setSaving] = useState(false);\n  const [viewMode, setViewMode] = useState('visual'); // 'visual' or 'code'\n  \n  useEffect(() => {\n    // Load template data\n    const fetchTemplate = async () => {\n      if (!templateId) return;\n      \n      const { data, error } = await supabase\n        .from('email_templates')\n        .select('*')\n        .eq('id', templateId)\n        .single();\n        \n      if (error) {\n        console.error('Error loading template:', error);\n        return;\n      }\n      \n      setTemplate(data);\n      setContent(data.content);\n    };\n    \n    fetchTemplate();\n  }, [templateId]);\n  \n  const handleContentChange = (newContent) => {\n    setContent(newContent);\n  };\n  \n  const generatePreview = async () => {\n    // Convert editor content to MJML if needed\n    const mjmlContent = viewMode === 'visual' ? convertToMjml(content) : content;\n    \n    // Render MJML to HTML\n    const html = await renderMjmlPreview(mjmlContent);\n    setPreviewHtml(html);\n  };\n  \n  const saveTemplate = async () => {\n    setSaving(true);\n    \n    try {\n      const mjmlContent = viewMode === 'visual' ? convertToMjml(content) : content;\n      const { data, error } = await supabase\n        .from('email_templates')\n        .update({\n          content: mjmlContent,\n          updated_at: new Date()\n        })\n        .eq('id', templateId);\n        \n      if (error) throw error;\n      \n      if (onSave) onSave(data);\n    } catch (error) {\n      console.error('Error saving template:', error);\n    } finally {\n      setSaving(false);\n    }\n  };\n  \n  return (\n    <div className=\"template-editor\">\n      <div className=\"editor-toolbar\">\n        <button onClick={() => setViewMode('visual')}>Visual Editor</button>\n        <button onClick={() => setViewMode('code')}>Code Editor</button>\n        <button onClick={generatePreview}>Preview</button>\n        <button onClick={saveTemplate} disabled={saving}>\n          {saving ? 'Saving...' : 'Save Template'}\n        </button>\n      </div>\n      \n      <div className=\"editor-container\">\n        {viewMode === 'visual' ? (\n          <Editor value={content} onChange={handleContentChange} />\n        ) : (\n          <textarea\n            value={content}\n            onChange={(e) => handleContentChange(e.target.value)}\n            style={{ width: '100%', height: '400px' }}\n          />\n        )}\n      </div>\n      \n      {previewHtml && (\n        <div className=\"preview-container\">\n          <h3>Preview</h3>\n          <div className=\"preview-frame\">\n            <iframe\n              srcDoc={previewHtml}\n              title=\"Email Preview\"\n              width=\"100%\"\n              height=\"500px\"\n              frameBorder=\"0\"\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TemplateEditor;\n```",
      "testStrategy": "1. Test template creation, editing, and deletion functionality\n2. Verify WYSIWYG editor correctly generates MJML\n3. Test template preview across different viewports\n4. Validate template versioning and history tracking\n5. Test variable substitution in templates\n6. Verify template duplication works correctly\n7. Test concurrent editing scenarios\n8. Validate UI responsiveness with large templates",
      "priority": "medium",
      "dependencies": [
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Campaign Management System",
      "description": "Develop a campaign management interface with scheduling capabilities, recipient targeting, and automation for recurring emails.",
      "details": "1. Design campaign management UI with listing, filtering, and status views\n2. Implement campaign creation workflow\n3. Create recipient selection interface using segments and tags\n4. Build scheduling functionality with timezone support\n5. Implement campaign preview and testing\n6. Create campaign duplication functionality\n7. Develop automation rules for recurring emails\n8. Add A/B testing capabilities\n9. Implement campaign status tracking\n\n```typescript\n// Example campaign creation component\nimport React, { useState } from 'react';\nimport { supabase } from '../lib/supabaseClient';\nimport { SegmentSelector } from '../components/SegmentSelector';\nimport { TemplateSelector } from '../components/TemplateSelector';\nimport { DateTimePicker } from '../components/DateTimePicker';\n\nconst CampaignCreator = () => {\n  const [campaign, setCampaign] = useState({\n    name: '',\n    subject: '',\n    from_name: 'Graceful Homeschooling',\n    from_email: 'hello@gracefulhomeschooling.com',\n    template_id: null,\n    segment_id: null,\n    scheduled_for: null,\n    is_recurring: false,\n    recurrence_pattern: null\n  });\n  \n  const [step, setStep] = useState(1); // Multi-step form\n  \n  const handleChange = (field, value) => {\n    setCampaign(prev => ({ ...prev, [field]: value }));\n  };\n  \n  const handleSegmentChange = (segmentId) => {\n    handleChange('segment_id', segmentId);\n  };\n  \n  const handleTemplateChange = (templateId) => {\n    handleChange('template_id', templateId);\n  };\n  \n  const handleScheduleChange = (date) => {\n    handleChange('scheduled_for', date);\n  };\n  \n  const toggleRecurring = () => {\n    handleChange('is_recurring', !campaign.is_recurring);\n  };\n  \n  const saveCampaign = async () => {\n    try {\n      const { data, error } = await supabase\n        .from('email_campaigns')\n        .insert([\n          {\n            name: campaign.name,\n            subject: campaign.subject,\n            from_name: campaign.from_name,\n            from_email: campaign.from_email,\n            template_id: campaign.template_id,\n            segment_id: campaign.segment_id,\n            scheduled_for: campaign.scheduled_for,\n            is_recurring: campaign.is_recurring,\n            recurrence_pattern: campaign.recurrence_pattern,\n            status: 'draft',\n            created_at: new Date()\n          }\n        ]);\n        \n      if (error) throw error;\n      \n      // Handle success - redirect to campaign detail or list\n    } catch (error) {\n      console.error('Error creating campaign:', error);\n    }\n  };\n  \n  const renderStepContent = () => {\n    switch (step) {\n      case 1:\n        return (\n          <div className=\"campaign-details\">\n            <h3>Campaign Details</h3>\n            <div className=\"form-group\">\n              <label>Campaign Name</label>\n              <input\n                type=\"text\"\n                value={campaign.name}\n                onChange={(e) => handleChange('name', e.target.value)}\n              />\n            </div>\n            <div className=\"form-group\">\n              <label>Subject Line</label>\n              <input\n                type=\"text\"\n                value={campaign.subject}\n                onChange={(e) => handleChange('subject', e.target.value)}\n              />\n            </div>\n            {/* Additional fields */}\n          </div>\n        );\n      case 2:\n        return (\n          <div className=\"campaign-content\">\n            <h3>Email Content</h3>\n            <TemplateSelector\n              selectedTemplateId={campaign.template_id}\n              onSelect={handleTemplateChange}\n            />\n          </div>\n        );\n      case 3:\n        return (\n          <div className=\"campaign-audience\">\n            <h3>Select Audience</h3>\n            <SegmentSelector\n              selectedSegmentId={campaign.segment_id}\n              onSelect={handleSegmentChange}\n            />\n          </div>\n        );\n      case 4:\n        return (\n          <div className=\"campaign-schedule\">\n            <h3>Schedule Campaign</h3>\n            <div className=\"form-group\">\n              <label>Send Date and Time</label>\n              <DateTimePicker\n                value={campaign.scheduled_for}\n                onChange={handleScheduleChange}\n              />\n            </div>\n            <div className=\"form-group\">\n              <label>\n                <input\n                  type=\"checkbox\"\n                  checked={campaign.is_recurring}\n                  onChange={toggleRecurring}\n                />\n                Make this a recurring campaign\n              </label>\n            </div>\n            {campaign.is_recurring && (\n              <div className=\"recurrence-options\">\n                {/* Recurrence pattern options */}\n              </div>\n            )}\n          </div>\n        );\n      default:\n        return null;\n    }\n  };\n  \n  return (\n    <div className=\"campaign-creator\">\n      <h2>Create New Campaign</h2>\n      \n      <div className=\"step-indicator\">\n        {/* Step indicators */}\n      </div>\n      \n      {renderStepContent()}\n      \n      <div className=\"form-actions\">\n        {step > 1 && (\n          <button onClick={() => setStep(step - 1)}>Previous</button>\n        )}\n        \n        {step < 4 ? (\n          <button onClick={() => setStep(step + 1)}>Next</button>\n        ) : (\n          <button onClick={saveCampaign}>Create Campaign</button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CampaignCreator;\n```",
      "testStrategy": "1. Test campaign creation workflow with various configurations\n2. Verify scheduling functionality with different timezones\n3. Test recipient targeting with different segments\n4. Validate campaign preview functionality\n5. Test campaign duplication\n6. Verify recurring campaign setup and execution\n7. Test A/B testing configuration\n8. Validate campaign status updates throughout lifecycle",
      "priority": "medium",
      "dependencies": [
        20,
        21
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Email Sending Service Implementation",
      "description": "Develop the core email sending service that handles different types of emails (transactional, marketing, educational) using Postmark's API.",
      "details": "1. Create a comprehensive email sending service\n2. Implement different sending methods for various email types\n3. Add template rendering with variable substitution\n4. Implement batch sending capabilities\n5. Add rate limiting and throttling\n6. Create retry mechanism for failed sends\n7. Implement logging and monitoring\n8. Add support for attachments and inline images\n\n```typescript\n// Example email sending service\nimport { PostmarkClient } from 'postmark';\nimport { renderTemplate } from './templateRenderer';\nimport { logger } from './logger';\n\nexport class EmailService {\n  private client: PostmarkClient;\n  \n  constructor(apiKey: string) {\n    this.client = new PostmarkClient(apiKey);\n  }\n  \n  /**\n   * Send a transactional email using a template\n   */\n  async sendTransactionalEmail(options: {\n    to: string;\n    subject: string;\n    templateId: string;\n    templateData: Record<string, any>;\n    from?: string;\n    replyTo?: string;\n    attachments?: Array<{ name: string, content: string, contentType: string }>;\n    messageStream?: string;\n  }) {\n    const {\n      to,\n      subject,\n      templateId,\n      templateData,\n      from = 'hello@gracefulhomeschooling.com',\n      replyTo,\n      attachments = [],\n      messageStream = 'outbound'\n    } = options;\n    \n    try {\n      const response = await this.client.sendEmailWithTemplate({\n        From: from,\n        To: to,\n        Subject: subject,\n        TemplateId: templateId,\n        TemplateModel: templateData,\n        ReplyTo: replyTo,\n        MessageStream: messageStream,\n        Attachments: attachments.map(att => ({\n          Name: att.name,\n          Content: att.content,\n          ContentType: att.contentType\n        }))\n      });\n      \n      logger.info('Transactional email sent', {\n        messageId: response.MessageID,\n        to,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: true,\n        messageId: response.MessageID\n      };\n    } catch (error) {\n      logger.error('Failed to send transactional email', {\n        error,\n        to,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: false,\n        error\n      };\n    }\n  }\n  \n  /**\n   * Send a marketing email to multiple recipients\n   */\n  async sendMarketingEmail(options: {\n    recipients: Array<{ email: string, data?: Record<string, any> }>;\n    subject: string;\n    templateId: string;\n    from?: string;\n    messageStream?: string;\n  }) {\n    const {\n      recipients,\n      subject,\n      templateId,\n      from = 'hello@gracefulhomeschooling.com',\n      messageStream = 'broadcast'\n    } = options;\n    \n    try {\n      // Split recipients into batches of 500 (Postmark's limit)\n      const batchSize = 500;\n      const batches = [];\n      \n      for (let i = 0; i < recipients.length; i += batchSize) {\n        batches.push(recipients.slice(i, i + batchSize));\n      }\n      \n      const results = [];\n      \n      for (const batch of batches) {\n        const messages = batch.map(recipient => ({\n          From: from,\n          To: recipient.email,\n          Subject: subject,\n          TemplateId: templateId,\n          TemplateModel: recipient.data || {},\n          MessageStream: messageStream\n        }));\n        \n        const response = await this.client.sendEmailBatch(messages);\n        results.push(...response);\n        \n        // Add a small delay between batches to avoid rate limits\n        if (batches.length > 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      }\n      \n      logger.info('Marketing email batch sent', {\n        recipientCount: recipients.length,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: true,\n        results\n      };\n    } catch (error) {\n      logger.error('Failed to send marketing email batch', {\n        error,\n        recipientCount: recipients.length,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: false,\n        error\n      };\n    }\n  }\n  \n  /**\n   * Send a test email to verify template rendering\n   */\n  async sendTestEmail(options: {\n    to: string;\n    subject: string;\n    templateId: string;\n    templateData: Record<string, any>;\n  }) {\n    return this.sendTransactionalEmail({\n      ...options,\n      subject: `[TEST] ${options.subject}`\n    });\n  }\n}\n```",
      "testStrategy": "1. Unit test each email sending method\n2. Test template rendering with various data sets\n3. Verify batch sending with different recipient counts\n4. Test rate limiting and throttling behavior\n5. Verify retry mechanism for failed sends\n6. Test logging captures appropriate information\n7. Validate attachment handling\n8. Test with different Postmark message streams",
      "priority": "high",
      "dependencies": [
        17,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Email Webhook Processing",
      "description": "Implement webhook handling for Postmark events to track email engagement metrics like opens, clicks, bounces, and spam reports.",
      "details": "1. Create webhook endpoint for Postmark events\n2. Implement handlers for different event types:\n   - Delivery\n   - Open\n   - Click\n   - Bounce\n   - Spam complaint\n   - Subscription change\n3. Store event data in the database\n4. Implement webhook authentication and validation\n5. Add error handling and retry logic\n6. Create background processing for high-volume events\n7. Implement event aggregation for analytics\n\n```typescript\n// Example webhook handler for Next.js API route\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '../../lib/supabaseClient';\nimport { verifyPostmarkWebhook } from '../../lib/postmarkUtils';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    // Verify webhook signature if Postmark provides one\n    if (!verifyPostmarkWebhook(req)) {\n      return res.status(401).json({ error: 'Invalid webhook signature' });\n    }\n    \n    const event = req.body;\n    \n    // Process different event types\n    switch (event.RecordType) {\n      case 'Delivery':\n        await processDeliveryEvent(event);\n        break;\n      case 'Open':\n        await processOpenEvent(event);\n        break;\n      case 'Click':\n        await processClickEvent(event);\n        break;\n      case 'Bounce':\n        await processBounceEvent(event);\n        break;\n      case 'SpamComplaint':\n        await processSpamComplaintEvent(event);\n        break;\n      case 'SubscriptionChange':\n        await processSubscriptionChangeEvent(event);\n        break;\n      default:\n        console.warn('Unknown event type:', event.RecordType);\n    }\n    \n    return res.status(200).json({ success: true });\n  } catch (error) {\n    console.error('Error processing webhook:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n\nasync function processDeliveryEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'delivery',\n      recipient: event.Recipient,\n      timestamp: new Date(event.DeliveredAt),\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processOpenEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'open',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ReceivedAt),\n      user_agent: event.UserAgent,\n      geo_location: event.Geo,\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processClickEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'click',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ReceivedAt),\n      user_agent: event.UserAgent,\n      geo_location: event.Geo,\n      link_url: event.OriginalLink,\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processBounceEvent(event) {\n  // Insert event record\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'bounce',\n      recipient: event.Recipient,\n      timestamp: new Date(event.BouncedAt),\n      bounce_type: event.Type,\n      bounce_reason: event.Description,\n      raw_event: event\n    }\n  ]);\n  \n  // Update user record for hard bounces\n  if (event.Type === 'HardBounce') {\n    await supabase.from('user_email_preferences')\n      .update({ \n        is_valid_email: false,\n        bounce_reason: event.Description,\n        updated_at: new Date()\n      })\n      .eq('email', event.Recipient);\n  }\n}\n\nasync function processSpamComplaintEvent(event) {\n  // Insert event record\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'spam_complaint',\n      recipient: event.Recipient,\n      timestamp: new Date(event.BouncedAt),\n      raw_event: event\n    }\n  ]);\n  \n  // Update user preferences to opt out\n  await supabase.from('user_email_preferences')\n    .update({ \n      marketing_opt_in: false,\n      updated_at: new Date(),\n      opt_out_reason: 'spam_complaint'\n    })\n    .eq('email', event.Recipient);\n}\n\nasync function processSubscriptionChangeEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'subscription_change',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ChangedAt),\n      subscription_change: event.SuppressionReason,\n      raw_event: event\n    }\n  ]);\n  \n  // Update user preferences based on subscription change\n  await supabase.from('user_email_preferences')\n    .update({ \n      marketing_opt_in: event.SuppressionReason !== 'Unsubscribed',\n      updated_at: new Date(),\n      opt_out_reason: event.SuppressionReason === 'Unsubscribed' ? 'unsubscribe' : null\n    })\n    .eq('email', event.Recipient);\n}\n```",
      "testStrategy": "1. Test webhook endpoint with sample Postmark event payloads\n2. Verify event data is correctly stored in the database\n3. Test webhook authentication and validation\n4. Verify error handling for malformed requests\n5. Test high-volume event processing\n6. Validate user preference updates based on events\n7. Test event aggregation for analytics\n8. Verify webhook endpoint security",
      "priority": "medium",
      "dependencies": [
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Email Analytics Dashboard",
      "description": "Build an analytics dashboard to visualize email performance metrics including opens, clicks, bounces, and engagement over time.",
      "details": "1. Design analytics dashboard UI with key metrics overview\n2. Implement data aggregation for email performance metrics\n3. Create visualizations for:\n   - Open rates\n   - Click-through rates\n   - Bounce rates\n   - Spam complaint rates\n   - Engagement over time\n4. Add filtering by campaign, date range, and email type\n5. Implement drill-down capabilities for detailed analysis\n6. Create exportable reports for stakeholders\n7. Add real-time updates for recent campaigns\n\n```typescript\n// Example analytics data fetching service\nimport { supabase } from '../lib/supabaseClient';\n\nexport async function getEmailAnalytics(filters: {\n  startDate?: Date;\n  endDate?: Date;\n  campaignId?: string;\n  emailType?: string;\n}) {\n  const {\n    startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Default to last 30 days\n    endDate = new Date(),\n    campaignId,\n    emailType\n  } = filters;\n  \n  // Base query for sent emails\n  let sentQuery = supabase\n    .from('email_events')\n    .select('count')\n    .eq('event_type', 'delivery')\n    .gte('timestamp', startDate.toISOString())\n    .lte('timestamp', endDate.toISOString());\n    \n  // Apply filters if provided\n  if (campaignId) {\n    sentQuery = sentQuery.eq('campaign_id', campaignId);\n  }\n  \n  if (emailType) {\n    sentQuery = sentQuery.eq('email_type', emailType);\n  }\n  \n  // Execute sent emails query\n  const { data: sentData, error: sentError } = await sentQuery;\n  \n  if (sentError) throw sentError;\n  \n  // Similar queries for opens, clicks, bounces, etc.\n  // ...\n  \n  // Get daily stats for time series\n  const { data: dailyStats, error: dailyError } = await supabase\n    .rpc('get_daily_email_stats', {\n      start_date: startDate.toISOString(),\n      end_date: endDate.toISOString(),\n      campaign_id: campaignId || null,\n      email_type: emailType || null\n    });\n    \n  if (dailyError) throw dailyError;\n  \n  // Calculate key metrics\n  const totalSent = sentData[0]?.count || 0;\n  const totalOpens = opensData[0]?.count || 0;\n  const totalClicks = clicksData[0]?.count || 0;\n  const totalBounces = bouncesData[0]?.count || 0;\n  const totalComplaints = complaintsData[0]?.count || 0;\n  \n  const openRate = totalSent > 0 ? (totalOpens / totalSent) * 100 : 0;\n  const clickRate = totalSent > 0 ? (totalClicks / totalSent) * 100 : 0;\n  const clickToOpenRate = totalOpens > 0 ? (totalClicks / totalOpens) * 100 : 0;\n  const bounceRate = totalSent > 0 ? (totalBounces / totalSent) * 100 : 0;\n  const complaintRate = totalSent > 0 ? (totalComplaints / totalSent) * 100 : 0;\n  \n  return {\n    summary: {\n      totalSent,\n      totalOpens,\n      totalClicks,\n      totalBounces,\n      totalComplaints,\n      openRate,\n      clickRate,\n      clickToOpenRate,\n      bounceRate,\n      complaintRate\n    },\n    dailyStats\n  };\n}\n\n// Example SQL function for daily stats (to be created in Supabase)\n/*\nCREATE OR REPLACE FUNCTION get_daily_email_stats(\n  start_date TIMESTAMP WITH TIME ZONE,\n  end_date TIMESTAMP WITH TIME ZONE,\n  campaign_id UUID,\n  email_type TEXT\n) RETURNS TABLE (\n  date DATE,\n  sent BIGINT,\n  opens BIGINT,\n  clicks BIGINT,\n  bounces BIGINT,\n  complaints BIGINT\n) AS $$\nBEGIN\n  RETURN QUERY\n  WITH dates AS (\n    SELECT generate_series(start_date::DATE, end_date::DATE, '1 day'::INTERVAL)::DATE AS date\n  ),\n  sent_counts AS (\n    SELECT\n      DATE(timestamp) AS date,\n      COUNT(*) AS count\n    FROM email_events\n    WHERE\n      event_type = 'delivery'\n      AND timestamp >= start_date\n      AND timestamp <= end_date\n      AND (campaign_id IS NULL OR campaign_id = $3)\n      AND (email_type IS NULL OR email_type = $4)\n    GROUP BY DATE(timestamp)\n  ),\n  open_counts AS (\n    -- Similar query for opens\n  ),\n  click_counts AS (\n    -- Similar query for clicks\n  ),\n  bounce_counts AS (\n    -- Similar query for bounces\n  ),\n  complaint_counts AS (\n    -- Similar query for complaints\n  )\n  SELECT\n    d.date,\n    COALESCE(s.count, 0) AS sent,\n    COALESCE(o.count, 0) AS opens,\n    COALESCE(c.count, 0) AS clicks,\n    COALESCE(b.count, 0) AS bounces,\n    COALESCE(cp.count, 0) AS complaints\n  FROM\n    dates d\n    LEFT JOIN sent_counts s ON d.date = s.date\n    LEFT JOIN open_counts o ON d.date = o.date\n    LEFT JOIN click_counts c ON d.date = c.date\n    LEFT JOIN bounce_counts b ON d.date = b.date\n    LEFT JOIN complaint_counts cp ON d.date = cp.date\n  ORDER BY\n    d.date;\nEND;\n$$ LANGUAGE plpgsql;\n*/\n```",
      "testStrategy": "1. Test data aggregation with various filter combinations\n2. Verify metric calculations are accurate\n3. Test dashboard performance with large datasets\n4. Validate visualization rendering with different data patterns\n5. Test export functionality for different report formats\n6. Verify real-time updates for recent campaigns\n7. Test dashboard responsiveness across different devices\n8. Validate filter interactions and state management",
      "priority": "medium",
      "dependencies": [
        24
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "User Email Preference Management",
      "description": "Implement global opt-in/opt-out preference management for users and ensure compliance with email regulations for Philippines audience.",
      "details": "1. Design user email preference UI\n2. Implement preference storage in the database\n3. Create API endpoints for preference management\n4. Add unsubscribe link processing from emails\n5. Implement preference center for users\n6. Add compliance features for email regulations\n7. Create preference history tracking\n8. Implement preference synchronization with Postmark\n\n```typescript\n// Example email preferences schema\n/*\nCREATE TABLE user_email_preferences (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  email VARCHAR(255) NOT NULL,\n  marketing_opt_in BOOLEAN DEFAULT TRUE,\n  educational_opt_in BOOLEAN DEFAULT TRUE,\n  transactional_opt_in BOOLEAN DEFAULT TRUE,\n  is_valid_email BOOLEAN DEFAULT TRUE,\n  bounce_reason TEXT,\n  opt_out_reason TEXT,\n  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id)\n);\n\n-- Preference history table for audit\nCREATE TABLE user_email_preference_history (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  email VARCHAR(255) NOT NULL,\n  preference_type VARCHAR(50) NOT NULL,\n  old_value BOOLEAN,\n  new_value BOOLEAN,\n  changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  changed_by UUID REFERENCES auth.users(id),\n  source VARCHAR(50) -- 'user', 'admin', 'system', 'unsubscribe_link'\n);\n*/\n\n// Example preference management component\nimport React, { useState, useEffect } from 'react';\nimport { supabase } from '../lib/supabaseClient';\n\nconst EmailPreferences = ({ userId }) => {\n  const [preferences, setPreferences] = useState({\n    marketing_opt_in: true,\n    educational_opt_in: true,\n    transactional_opt_in: true\n  });\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [message, setMessage] = useState('');\n  \n  useEffect(() => {\n    // Load user preferences\n    const fetchPreferences = async () => {\n      setLoading(true);\n      \n      const { data, error } = await supabase\n        .from('user_email_preferences')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n        \n      if (error && error.code !== 'PGRST116') { // PGRST116 is \"not found\"\n        console.error('Error loading preferences:', error);\n        setMessage('Failed to load preferences');\n      } else if (data) {\n        setPreferences({\n          marketing_opt_in: data.marketing_opt_in,\n          educational_opt_in: data.educational_opt_in,\n          transactional_opt_in: data.transactional_opt_in\n        });\n      }\n      \n      setLoading(false);\n    };\n    \n    fetchPreferences();\n  }, [userId]);\n  \n  const handleToggle = (preference) => {\n    setPreferences(prev => ({\n      ...prev,\n      [preference]: !prev[preference]\n    }));\n  };\n  \n  const savePreferences = async () => {\n    setSaving(true);\n    setMessage('');\n    \n    try {\n      // Get user's email\n      const { data: userData, error: userError } = await supabase.auth.getUser();\n      \n      if (userError) throw userError;\n      \n      const email = userData.user.email;\n      \n      // Update preferences\n      const { error } = await supabase\n        .from('user_email_preferences')\n        .upsert({\n          user_id: userId,\n          email,\n          marketing_opt_in: preferences.marketing_opt_in,\n          educational_opt_in: preferences.educational_opt_in,\n          transactional_opt_in: preferences.transactional_opt_in,\n          updated_at: new Date()\n        }, {\n          onConflict: 'user_id'\n        });\n        \n      if (error) throw error;\n      \n      // Record history for each changed preference\n      // This would typically be handled by a database trigger\n      \n      setMessage('Preferences saved successfully');\n    } catch (error) {\n      console.error('Error saving preferences:', error);\n      setMessage('Failed to save preferences');\n    } finally {\n      setSaving(false);\n    }\n  };\n  \n  if (loading) {\n    return <div>Loading preferences...</div>;\n  }\n  \n  return (\n    <div className=\"email-preferences\">\n      <h2>Email Preferences</h2>\n      \n      {message && (\n        <div className={message.includes('Failed') ? 'error-message' : 'success-message'}>\n          {message}\n        </div>\n      )}\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.marketing_opt_in}\n            onChange={() => handleToggle('marketing_opt_in')}\n          />\n          Marketing Emails (Sales, promotions, and special offers)\n        </label>\n      </div>\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.educational_opt_in}\n            onChange={() => handleToggle('educational_opt_in')}\n          />\n          Educational Content (Class reminders, instructional content)\n        </label>\n      </div>\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.transactional_opt_in}\n            onChange={() => handleToggle('transactional_opt_in')}\n            disabled={true} // Transactional emails can't be opted out of\n          />\n          Transactional Emails (Account updates, purchase confirmations)\n        </label>\n        <small>These emails are required for your account and cannot be disabled.</small>\n      </div>\n      \n      <div className=\"preference-actions\">\n        <button\n          onClick={savePreferences}\n          disabled={saving}\n        >\n          {saving ? 'Saving...' : 'Save Preferences'}\n        </button>\n      </div>\n      \n      <div className=\"preference-info\">\n        <p>\n          We respect your privacy and are committed to protecting your personal data.\n          For more information, please see our <a href=\"/privacy-policy\">Privacy Policy</a>.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default EmailPreferences;\n```",
      "testStrategy": "1. Test preference saving and loading functionality\n2. Verify unsubscribe link processing\n3. Test preference center UI across different devices\n4. Validate compliance with email regulations\n5. Test preference history tracking\n6. Verify preference synchronization with Postmark\n7. Test preference changes impact on email sending\n8. Validate security of preference management endpoints",
      "priority": "high",
      "dependencies": [
        19,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "Authentication Email Templates",
      "description": "Create and implement custom email templates for authentication flows including registration, welcome, password reset, and magic links.",
      "details": "1. Design and implement the following authentication email templates:\n   - Email verification\n   - Welcome email\n   - Password reset\n   - Magic link authentication\n2. Ensure templates follow Graceful Homeschooling brand guidelines\n3. Implement responsive design using MJML\n4. Add appropriate security messaging\n5. Ensure clear call-to-action buttons\n6. Implement template variables for personalization\n\n```mjml\n<!-- Example MJML template for password reset email -->\n<mjml>\n  <mj-head>\n    <mj-title>Reset Your Graceful Homeschooling Password</mj-title>\n    <mj-attributes>\n      <mj-all font-family=\"Inter, Arial, sans-serif\" />\n      <mj-text font-weight=\"400\" font-size=\"16px\" color=\"#000000\" line-height=\"24px\" />\n      <mj-section padding=\"0px\" />\n    </mj-attributes>\n    <mj-style>\n      h1, h2, h3, h4 { font-family: 'Playfair Display', Georgia, serif; }\n      .gh-primary { color: #b08ba5; }\n      .gh-secondary { color: #f1b5bc; }\n      .gh-tertiary { color: #9ac5d9; }\n    </mj-style>\n    <mj-font name=\"Inter\" href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap\" />\n    <mj-font name=\"Playfair Display\" href=\"https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap\" />\n  </mj-head>\n  <mj-body background-color=\"#ffffff\">\n    <!-- Header -->\n    <mj-section background-color=\"#b08ba5\" padding=\"20px\">\n      <mj-column>\n        <mj-image width=\"200px\" src=\"{{logoUrl}}\" alt=\"Graceful Homeschooling\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Content -->\n    <mj-section padding=\"20px\">\n      <mj-column>\n        <mj-text>\n          <h1 style=\"font-family: 'Playfair Display', Georgia, serif; color: #b08ba5;\">Reset Your Password</h1>\n        </mj-text>\n        <mj-text>\n          <p>Hello {{name}},</p>\n          <p>We received a request to reset your password for your Graceful Homeschooling account. If you didn't make this request, you can safely ignore this email.</p>\n          <p>To reset your password, click the button below. This link will expire in 24 hours.</p>\n        </mj-text>\n        <mj-button background-color=\"#b08ba5\" color=\"white\" href=\"{{resetUrl}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"600\">\n          Reset Password\n        </mj-button>\n        <mj-text>\n          <p>If the button above doesn't work, you can copy and paste the following link into your browser:</p>\n          <p style=\"word-break: break-all;\"><a href=\"{{resetUrl}}\" style=\"color: #9ac5d9;\">{{resetUrl}}</a></p>\n          <p>For security reasons, this password reset link will expire in 24 hours. If you need to reset your password after that time, please request a new reset link.</p>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Security Notice -->\n    <mj-section padding=\"0 20px 20px\">\n      <mj-column border=\"1px solid #f1b5bc\" border-radius=\"4px\" background-color=\"#fff9fa\" padding=\"10px\">\n        <mj-text font-size=\"14px\">\n          <p><strong>Security Notice:</strong> If you didn't request a password reset, please contact us immediately at <a href=\"mailto:support@gracefulhomeschooling.com\" style=\"color: #9ac5d9;\">support@gracefulhomeschooling.com</a>.</p>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Footer -->\n    <mj-section background-color=\"#f6f6f6\" padding=\"20px\">\n      <mj-column>\n        <mj-text align=\"center\" font-size=\"12px\">\n          <p>&copy; {{year}} Graceful Homeschooling. All rights reserved.</p>\n          <p>This email was sent to you because you have an account with Graceful Homeschooling.</p>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n```\n\n```typescript\n// Example function to register authentication templates with Postmark\nasync function registerAuthTemplates() {\n  const postmarkClient = new PostmarkClient(process.env.POSTMARK_API_TOKEN);\n  \n  // Email verification template\n  const verificationTemplate = fs.readFileSync('./templates/email-verification.mjml', 'utf8');\n  const verificationHtml = mjml2html(verificationTemplate).html;\n  \n  await postmarkClient.createTemplate({\n    Name: 'Email Verification',\n    Subject: 'Verify Your Graceful Homeschooling Email',\n    HtmlBody: verificationHtml,\n    TextBody: 'Please verify your email address by clicking the following link: {{verificationUrl}}',\n    TemplateType: 'Standard'\n  });\n  \n  // Similar code for other authentication templates...\n  \n  // Configure Supabase to use these templates\n  // This would typically be done through the Supabase dashboard\n  // or management API if available\n}\n```",
      "testStrategy": "1. Test template rendering with various user data\n2. Verify responsive design across different email clients\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate security messaging is clear and accurate",
      "priority": "high",
      "dependencies": [
        18,
        19
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Transactional Email Templates",
      "description": "Create and implement transactional email templates for order confirmations, class enrollments, and other system notifications.",
      "details": "1. Design and implement the following transactional email templates:\n   - Order confirmation\n   - Class enrollment confirmation\n   - Payment receipt\n   - Account updates\n   - System notifications\n2. Ensure templates follow Graceful Homeschooling brand guidelines\n3. Implement responsive design using MJML\n4. Add appropriate transaction details and formatting\n5. Ensure clear call-to-action buttons where applicable\n6. Implement template variables for personalization and transaction details\n\n```mjml\n<!-- Example MJML template for class enrollment confirmation -->\n<mjml>\n  <mj-head>\n    <mj-title>Your Class Enrollment Confirmation</mj-title>\n    <mj-attributes>\n      <mj-all font-family=\"Inter, Arial, sans-serif\" />\n      <mj-text font-weight=\"400\" font-size=\"16px\" color=\"#000000\" line-height=\"24px\" />\n      <mj-section padding=\"0px\" />\n    </mj-attributes>\n    <mj-style>\n      h1, h2, h3, h4 { font-family: 'Playfair Display', Georgia, serif; }\n      .gh-primary { color: #b08ba5; }\n      .gh-secondary { color: #f1b5bc; }\n      .gh-tertiary { color: #9ac5d9; }\n      .class-details { border: 1px solid #e0e0e0; border-radius: 4px; }\n      .class-details th { background-color: #f6f6f6; text-align: left; padding: 8px; }\n      .class-details td { padding: 8px; }\n    </mj-style>\n    <mj-font name=\"Inter\" href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap\" />\n    <mj-font name=\"Playfair Display\" href=\"https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap\" />\n  </mj-head>\n  <mj-body background-color=\"#ffffff\">\n    <!-- Header -->\n    <mj-section background-color=\"#b08ba5\" padding=\"20px\">\n      <mj-column>\n        <mj-image width=\"200px\" src=\"{{logoUrl}}\" alt=\"Graceful Homeschooling\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Content -->\n    <mj-section padding=\"20px\">\n      <mj-column>\n        <mj-text>\n          <h1 style=\"font-family: 'Playfair Display', Georgia, serif; color: #b08ba5;\">Class Enrollment Confirmation</h1>\n        </mj-text>\n        <mj-text>\n          <p>Hello {{name}},</p>\n          <p>Thank you for enrolling in the following class with Graceful Homeschooling. We're excited to have you join us!</p>\n        </mj-text>\n        \n        <!-- Class Details -->\n        <mj-table css-class=\"class-details\">\n          <tr>\n            <th>Class Name</th>\n            <td>{{className}}</td>\n          </tr>\n          <tr>\n            <th>Instructor</th>\n            <td>{{instructorName}}</td>\n          </tr>\n          <tr>\n            <th>Schedule</th>\n            <td>{{classSchedule}}</td>\n          </tr>\n          <tr>\n            <th>Start Date</th>\n            <td>{{startDate}}</td>\n          </tr>\n          <tr>\n            <th>Location</th>\n            <td>{{classLocation}}</td>\n          </tr>\n        </mj-table>\n        \n        <mj-spacer height=\"20px\" />\n        \n        <mj-text>\n          <p>You can access your class materials and information by logging into your account.</p>\n        </mj-text>\n        \n        <mj-button background-color=\"#9ac5d9\" color=\"white\" href=\"{{classUrl}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"600\">\n          View Class Details\n        </mj-button>\n        \n        <mj-text>\n          <p>If you have any questions about your enrollment, please don't hesitate to contact us at <a href=\"mailto:support@gracefulhomeschooling.com\" style=\"color: #9ac5d9;\">support@gracefulhomeschooling.com</a>.</p>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Calendar Reminder -->\n    <mj-section padding=\"0 20px 20px\">\n      <mj-column border=\"1px solid #9ac5d9\" border-radius=\"4px\" background-color=\"#f5f9fc\" padding=\"10px\">\n        <mj-text>\n          <p><strong>Add to Calendar:</strong> Don't miss your first class! Add it to your calendar using one of the options below:</p>\n        </mj-text>\n        <mj-button background-color=\"#9ac5d9\" color=\"white\" href=\"{{googleCalendarUrl}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"500\" padding=\"0 10px\">\n          Google Calendar\n        </mj-button>\n        <mj-button background-color=\"#9ac5d9\" color=\"white\" href=\"{{icsFileUrl}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"500\" padding=\"0 10px\">\n          iCal / Outlook\n        </mj-button>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Footer -->\n    <mj-section background-color=\"#f6f6f6\" padding=\"20px\">\n      <mj-column>\n        <mj-text align=\"center\" font-size=\"12px\">\n          <p>&copy; {{year}} Graceful Homeschooling. All rights reserved.</p>\n          <p>This is a transactional email related to your account activity.</p>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n```\n\n```typescript\n// Example function to register transactional templates with Postmark\nasync function registerTransactionalTemplates() {\n  const postmarkClient = new PostmarkClient(process.env.POSTMARK_API_TOKEN);\n  \n  // Class enrollment template\n  const enrollmentTemplate = fs.readFileSync('./templates/class-enrollment.mjml', 'utf8');\n  const enrollmentHtml = mjml2html(enrollmentTemplate).html;\n  \n  await postmarkClient.createTemplate({\n    Name: 'Class Enrollment Confirmation',\n    Subject: 'Your Enrollment in {{className}} is Confirmed',\n    HtmlBody: enrollmentHtml,\n    TextBody: 'Thank you for enrolling in {{className}}. Your class is scheduled for {{classSchedule}} starting on {{startDate}}.',\n    TemplateType: 'Standard'\n  });\n  \n  // Similar code for other transactional templates...\n}\n```",
      "testStrategy": "1. Test template rendering with various transaction data\n2. Verify responsive design across different email clients\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate transaction details are clearly presented",
      "priority": "high",
      "dependencies": [
        18,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "Marketing Email Templates",
      "description": "Create and implement marketing email templates for campaigns, promotions, and educational content following brand guidelines.",
      "details": "1. Design and implement the following marketing email templates:\n   - Newsletter template\n   - Promotion/sale announcement template\n   - Free class invitation template\n   - Educational content template\n   - Product announcement template\n2. Ensure templates follow Graceful Homeschooling brand guidelines\n3. Implement responsive design using MJML\n4. Add appropriate marketing content sections and layouts\n5. Ensure clear call-to-action buttons\n6. Implement template variables for personalization\n7. Add required unsubscribe links and compliance elements\n\n```mjml\n<!-- Example MJML template for promotion/sale announcement -->\n<mjml>\n  <mj-head>\n    <mj-title>Special Offer from Graceful Homeschooling</mj-title>\n    <mj-attributes>\n      <mj-all font-family=\"Inter, Arial, sans-serif\" />\n      <mj-text font-weight=\"400\" font-size=\"16px\" color=\"#000000\" line-height=\"24px\" />\n      <mj-section padding=\"0px\" />\n    </mj-attributes>\n    <mj-style>\n      h1, h2, h3, h4 { font-family: 'Playfair Display', Georgia, serif; }\n      .gh-primary { color: #b08ba5; }\n      .gh-secondary { color: #f1b5bc; }\n      .gh-tertiary { color: #9ac5d9; }\n      .promotion-box { border: 2px dashed #f1b5bc; border-radius: 8px; }\n    </mj-style>\n    <mj-font name=\"Inter\" href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap\" />\n    <mj-font name=\"Playfair Display\" href=\"https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap\" />\n  </mj-head>\n  <mj-body background-color=\"#ffffff\">\n    <!-- Header -->\n    <mj-section background-color=\"#b08ba5\" padding=\"20px\">\n      <mj-column>\n        <mj-image width=\"200px\" src=\"{{logoUrl}}\" alt=\"Graceful Homeschooling\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Hero Section -->\n    <mj-section padding=\"0\">\n      <mj-column>\n        <mj-image src=\"{{heroImageUrl}}\" alt=\"Special Offer\" padding=\"0\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Main Content -->\n    <mj-section padding=\"20px\">\n      <mj-column>\n        <mj-text>\n          <h1 style=\"font-family: 'Playfair Display', Georgia, serif; color: #b08ba5; text-align: center;\">{{promotionHeadline}}</h1>\n        </mj-text>\n        <mj-text align=\"center\">\n          <p>Hello {{firstName}},</p>\n          <p>{{promotionIntro}}</p>\n        </mj-text>\n        \n        <!-- Promotion Box -->\n        <mj-section css-class=\"promotion-box\" padding=\"20px\" border=\"2px dashed #f1b5bc\" border-radius=\"8px\" background-color=\"#fff9fa\">\n          <mj-column>\n            <mj-text align=\"center\" font-size=\"24px\" font-weight=\"bold\" color=\"#f1b5bc\">\n              {{promotionOffer}}\n            </mj-text>\n            <mj-text align=\"center\">\n              <p>Use code: <strong>{{promotionCode}}</strong></p>\n              <p>Offer valid until: {{expirationDate}}</p>\n            </mj-text>\n          </mj-column>\n        </mj-section>\n        \n        <mj-spacer height=\"20px\" />\n        \n        <mj-text>\n          <p>{{promotionDetails}}</p>\n        </mj-text>\n        \n        <mj-button background-color=\"#f1b5bc\" color=\"white\" href=\"{{promotionUrl}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"600\">\n          {{callToAction}}\n        </mj-button>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Featured Products/Classes -->\n    <mj-section padding=\"0 20px 20px\">\n      <mj-column>\n        <mj-text>\n          <h2 style=\"font-family: 'Playfair Display', Georgia, serif; color: #9ac5d9;\">Featured Classes</h2>\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <mj-section padding=\"0 20px 20px\">\n      {{#each featuredItems}}\n      <mj-column width=\"50%\" padding=\"10px\">\n        <mj-image src=\"{{this.imageUrl}}\" alt=\"{{this.name}}\" padding=\"0\" />\n        <mj-text font-weight=\"600\" padding-top=\"10px\">\n          {{this.name}}\n        </mj-text>\n        <mj-text font-size=\"14px\" padding-top=\"0\">\n          {{this.description}}\n        </mj-text>\n        <mj-button background-color=\"#9ac5d9\" color=\"white\" href=\"{{this.url}}\" border-radius=\"4px\" font-family=\"Inter, Arial, sans-serif\" font-weight=\"500\" padding=\"0 10px\">\n          Learn More\n        </mj-button>\n      </mj-column>\n      {{/each}}\n    </mj-section>\n    \n    <!-- Footer -->\n    <mj-section background-color=\"#f6f6f6\" padding=\"20px\">\n      <mj-column>\n        <mj-text align=\"center\" font-size=\"12px\">\n          <p>&copy; {{year}} Graceful Homeschooling. All rights reserved.</p>\n          <p>You're receiving this email because you've subscribed to marketing communications from Graceful Homeschooling.</p>\n          <p><a href=\"{{preferencesUrl}}\" style=\"color: #9ac5d9;\">Update your preferences</a> | <a href=\"{{unsubscribeUrl}}\" style=\"color: #9ac5d9;\">Unsubscribe</a></p>\n        </mj-text>\n        <mj-social font-size=\"15px\" icon-size=\"30px\" mode=\"horizontal\" padding=\"0\">\n          <mj-social-element name=\"facebook\" href=\"https://facebook.com/gracefulhomeschooling\" background-color=\"#b08ba5\"></mj-social-element>\n          <mj-social-element name=\"instagram\" href=\"https://instagram.com/gracefulhomeschooling\" background-color=\"#b08ba5\"></mj-social-element>\n          <mj-social-element name=\"youtube\" href=\"https://youtube.com/gracefulhomeschooling\" background-color=\"#b08ba5\"></mj-social-element>\n        </mj-social>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n```\n\n```typescript\n// Example function to register marketing templates with Postmark\nasync function registerMarketingTemplates() {\n  const postmarkClient = new PostmarkClient(process.env.POSTMARK_API_TOKEN);\n  \n  // Promotion template\n  const promotionTemplate = fs.readFileSync('./templates/promotion-announcement.mjml', 'utf8');\n  const promotionHtml = mjml2html(promotionTemplate).html;\n  \n  await postmarkClient.createTemplate({\n    Name: 'Promotion Announcement',\n    Subject: '{{promotionSubject}}',\n    HtmlBody: promotionHtml,\n    TextBody: 'Special offer for Graceful Homeschooling members! {{promotionOffer}} Use code: {{promotionCode}}. Offer valid until: {{expirationDate}}. {{promotionUrl}}',\n    TemplateType: 'Standard'\n  });\n  \n  // Similar code for other marketing templates...\n}\n```",
      "testStrategy": "1. Test template rendering with various marketing content\n2. Verify responsive design across different email clients\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate unsubscribe links and compliance elements",
      "priority": "medium",
      "dependencies": [
        18,
        26
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "Email Campaign Scheduling and Automation",
      "description": "Implement scheduling functionality for email campaigns and automation for recurring emails such as class reminders.",
      "details": "1. Design and implement campaign scheduling system\n2. Create automation rules for recurring emails\n3. Implement timezone handling for scheduled sends\n4. Add batch processing for large campaigns\n5. Create retry mechanism for failed sends\n6. Implement campaign status tracking and notifications\n7. Add campaign pause/resume functionality\n8. Create campaign analytics tracking\n\n```typescript\n// Example campaign scheduler implementation\nimport { CronJob } from 'cron';\nimport { supabase } from '../lib/supabaseClient';\nimport { EmailService } from '../lib/emailService';\nimport { logger } from '../lib/logger';\n\nconst emailService = new EmailService(process.env.POSTMARK_API_TOKEN);\n\n// Initialize scheduler\nexport function initCampaignScheduler() {\n  // Check for campaigns to send every minute\n  const job = new CronJob('* * * * *', async function() {\n    await processPendingCampaigns();\n    await processRecurringCampaigns();\n  });\n  \n  job.start();\n  logger.info('Campaign scheduler initialized');\n}\n\n// Process one-time campaigns that are scheduled to send\nasync function processPendingCampaigns() {\n  const now = new Date();\n  \n  // Find campaigns that are scheduled to send now\n  const { data: campaigns, error } = await supabase\n    .from('email_campaigns')\n    .select('*')\n    .eq('status', 'scheduled')\n    .eq('is_recurring', false)\n    .lte('scheduled_for', now.toISOString())\n    .order('scheduled_for', { ascending: true })\n    .limit(5); // Process in small batches\n    \n  if (error) {\n    logger.error('Error fetching pending campaigns', { error });\n    return;\n  }\n  \n  if (!campaigns || campaigns.length === 0) {\n    return; // No campaigns to process\n  }\n  \n  for (const campaign of campaigns) {\n    await processCampaign(campaign);\n  }\n}\n\n// Process recurring campaigns\nasync function processRecurringCampaigns() {\n  const now = new Date();\n  \n  // Find recurring campaigns that need to be processed\n  const { data: campaigns, error } = await supabase\n    .from('email_campaigns')\n    .select('*')\n    .eq('status', 'active')\n    .eq('is_recurring', true)\n    .lte('next_send_date', now.toISOString())\n    .order('next_send_date', { ascending: true })\n    .limit(5); // Process in small batches\n    \n  if (error) {\n    logger.error('Error fetching recurring campaigns', { error });\n    return;\n  }\n  \n  if (!campaigns || campaigns.length === 0) {\n    return; // No campaigns to process\n  }\n  \n  for (const campaign of campaigns) {\n    await processCampaign(campaign);\n    \n    // Calculate next send date based on recurrence pattern\n    const nextSendDate = calculateNextSendDate(campaign.recurrence_pattern, now);\n    \n    // Update campaign with next send date\n    await supabase\n      .from('email_campaigns')\n      .update({\n        next_send_date: nextSendDate.toISOString(),\n        last_sent_at: now.toISOString()\n      })\n      .eq('id', campaign.id);\n  }\n}\n\n// Process a single campaign\nasync function processCampaign(campaign) {\n  try {\n    // Update campaign status to processing\n    await supabase\n      .from('email_campaigns')\n      .update({ status: 'processing', processing_started_at: new Date().toISOString() })\n      .eq('id', campaign.id);\n    \n    // Get recipients based on segment\n    const recipients = await getRecipientsForCampaign(campaign);\n    \n    if (!recipients || recipients.length === 0) {\n      logger.warn('No recipients found for campaign', { campaignId: campaign.id });\n      await updateCampaignStatus(campaign.id, 'completed', 'No recipients found');\n      return;\n    }\n    \n    // Get template data\n    const { data: template, error: templateError } = await supabase\n      .from('email_templates')\n      .select('*')\n      .eq('id', campaign.template_id)\n      .single();\n      \n    if (templateError) {\n      logger.error('Error fetching template for campaign', { campaignId: campaign.id, error: templateError });\n      await updateCampaignStatus(campaign.id, 'error', 'Template not found');\n      return;\n    }\n    \n    // Send campaign\n    const result = await emailService.sendMarketingEmail({\n      recipients: recipients.map(r => ({\n        email: r.email,\n        data: {\n          firstName: r.first_name,\n          lastName: r.last_name,\n          // Add other personalization variables\n          unsubscribeUrl: `${process.env.NEXT_PUBLIC_APP_URL}/unsubscribe?email=${encodeURIComponent(r.email)}&token=${generateUnsubscribeToken(r.email)}`,\n          preferencesUrl: `${process.env.NEXT_PUBLIC_APP_URL}/preferences?email=${encodeURIComponent(r.email)}&token=${generatePreferencesToken(r.email)}`\n        }\n      })),\n      subject: campaign.subject,\n      templateId: template.postmark_template_id,\n      from: `${campaign.from_name} <${campaign.from_email}>`,\n      messageStream: 'broadcast'\n    });\n    \n    if (!result.success) {\n      throw new Error('Failed to send campaign: ' + JSON.stringify(result.error));\n    }\n    \n    // Update campaign status to completed\n    await updateCampaignStatus(campaign.id, 'completed', `Sent to ${recipients.length} recipients`);\n    \n    // Record campaign metrics\n    await supabase\n      .from('campaign_metrics')\n      .insert({\n        campaign_id: campaign.id,\n        recipient_count: recipients.length,\n        sent_at: new Date().toISOString()\n      });\n      \n  } catch (error) {\n    logger.error('Error processing campaign', { campaignId: campaign.id, error });\n    await updateCampaignStatus(campaign.id, 'error', error.message);\n  }\n}\n\n// Helper function to update campaign status\nasync function updateCampaignStatus(campaignId, status, statusMessage = '') {\n  await supabase\n    .from('email_campaigns')\n    .update({\n      status,\n      status_message: statusMessage,\n      updated_at: new Date().toISOString(),\n      processing_completed_at: status !== 'processing' ? new Date().toISOString() : null\n    })\n    .eq('id', campaignId);\n}\n\n// Helper function to get recipients for a campaign\nasync function getRecipientsForCampaign(campaign) {\n  // Get segment definition\n  const { data: segment, error: segmentError } = await supabase\n    .from('user_segments')\n    .select('*')\n    .eq('id', campaign.segment_id)\n    .single();\n    \n  if (segmentError) {\n    logger.error('Error fetching segment for campaign', { campaignId: campaign.id, error: segmentError });\n    throw new Error('Segment not found');\n  }\n  \n  // Evaluate segment to get recipient IDs\n  const recipientIds = await evaluateSegment(segment.id);\n  \n  // Get recipient details\n  const { data: recipients, error: recipientsError } = await supabase\n    .from('profiles')\n    .select('email, first_name, last_name')\n    .in('id', recipientIds)\n    .eq('email_verified', true); // Only send to verified emails\n    \n  if (recipientsError) {\n    logger.error('Error fetching recipients for campaign', { campaignId: campaign.id, error: recipientsError });\n    throw new Error('Failed to fetch recipients');\n  }\n  \n  return recipients;\n}\n\n// Helper function to calculate next send date for recurring campaigns\nfunction calculateNextSendDate(recurrencePattern, fromDate) {\n  const pattern = JSON.parse(recurrencePattern);\n  const nextDate = new Date(fromDate);\n  \n  switch (pattern.frequency) {\n    case 'daily':\n      nextDate.setDate(nextDate.getDate() + pattern.interval);\n      break;\n    case 'weekly':\n      nextDate.setDate(nextDate.getDate() + (pattern.interval * 7));\n      break;\n    case 'monthly':\n      nextDate.setMonth(nextDate.getMonth() + pattern.interval);\n      break;\n    default:\n      throw new Error(`Unknown frequency: ${pattern.frequency}`);\n  }\n  \n  return nextDate;\n}\n\n// Helper functions for security tokens\nfunction generateUnsubscribeToken(email) {\n  // Implementation would use a secure method to generate a token\n  // that can be validated when the unsubscribe link is clicked\n  return 'token'; // Placeholder\n}\n\nfunction generatePreferencesToken(email) {\n  // Similar to unsubscribe token\n  return 'token'; // Placeholder\n}\n```",
      "testStrategy": "1. Test campaign scheduling with various time configurations\n2. Verify timezone handling for different user locations\n3. Test recurring campaign patterns (daily, weekly, monthly)\n4. Validate batch processing for large recipient lists\n5. Test retry mechanism for failed sends\n6. Verify campaign status updates throughout the process\n7. Test pause/resume functionality\n8. Validate analytics tracking for scheduled campaigns",
      "priority": "medium",
      "dependencies": [
        22,
        23
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}