{
  "tasks": [
    {
      "id": 1,
      "title": "Audit and Document Existing User Data Schema",
      "description": "Review all existing user-related tables, relationships, and data structures to identify gaps and requirements for the admin system.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Analyze the current Supabase database schema focusing on unified_profiles, enrollments, shopify_orders, shopify_order_items, and related tables. Document the current state, identify missing fields needed for admin functionality, and create an ERD (Entity Relationship Diagram) showing all relationships. Pay special attention to how user data is currently structured and where administrative metadata is stored. The schema enhancements have been implemented in the database using Supabase migrations, including administrative fields in unified_profiles, tables for user notes, admin audit logging, and user activity tracking, search optimization with trigram indexes, a unified purchase history view, and helper functions for admin operations. The documentation has been created in ProjectDocs/admin-user-schema-audit.md.",
      "testStrategy": "Produce comprehensive documentation including current schema diagrams, identified gaps, and implemented changes. Review with stakeholders to ensure all requirements are captured and properly implemented.",
      "subtasks": [
        {
          "id": 1,
          "title": "Extract and Document Current User-Related Tables Schema",
          "description": "Extract the complete schema definition for all user-related tables from Supabase, including unified_profiles, enrollments, shopify_orders, shopify_order_items, and document their current structure.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Connect to the Supabase database using appropriate credentials\n2. Use SQL information_schema queries to extract table definitions, columns, data types, constraints, and indexes for the primary user-related tables\n3. Document each table's purpose, primary keys, foreign keys, and unique constraints\n4. Create a comprehensive data dictionary listing all fields with their data types, constraints, and business purpose\n5. Identify which fields store user identity information, contact details, and administrative metadata\n6. Document any existing triggers or functions that modify these tables\n\nTesting approach:\n- Verify the extracted schema matches the actual database structure\n- Cross-check documentation against sample data to ensure all fields are properly documented",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Document Views and Functions Related to User Data",
          "description": "Analyze and document all views, functions, and triggers that interact with user data, focusing on monthly_enrollments_view, revenue_analysis_view, marketing_source_view, unified purchase history view, and related functions/triggers, including the newly implemented admin helper functions.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Extract the definitions of all views that present or transform user data, including the new unified purchase history view\n2. Document each view's purpose, source tables, and transformation logic\n3. Extract and document all functions and stored procedures that modify or access user data, including the newly implemented admin helper functions\n4. Document triggers that affect user-related tables, including any new ones for admin audit logging\n5. Create a dependency map showing how views and functions relate to the base tables\n6. Identify which views and functions would need to be updated if the schema changes further\n7. Update the ProjectDocs/admin-user-schema-audit.md with the views and functions documentation\n\nTesting approach:\n- Verify all views can be successfully queried\n- Confirm function documentation matches actual behavior by testing with sample inputs\n- Validate that all newly implemented admin helper functions are properly documented",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Map Entity Relationships and Create ERD",
          "description": "Create a comprehensive Entity Relationship Diagram (ERD) showing all user-related tables, their relationships, cardinality, and how they connect to other parts of the system, including the newly added tables for user notes, admin audit logging, and user activity tracking.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Use a database modeling tool (e.g., dbdiagram.io, Lucidchart, or similar) to create the ERD\n2. Include all user-related tables documented in subtask 1\n3. Add the newly implemented tables for user notes, admin audit logging, and user activity tracking\n4. Map all relationships between tables, showing primary and foreign keys\n5. Document cardinality of relationships (one-to-one, one-to-many, many-to-many)\n6. Include views from subtask 2 in the diagram, showing their data sources\n7. Color-code or group tables by functional area (user identity, transactions, enrollments, admin functionality, etc.)\n8. Export the ERD in both editable format and as a PNG/PDF for documentation\n9. Update the ProjectDocs/admin-user-schema-audit.md with the ERD\n\nTesting approach:\n- Verify all tables from subtask 1 and newly implemented tables are included in the ERD\n- Confirm all relationships are correctly represented\n- Have another team member review the ERD for accuracy and completeness",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Identify Schema Gaps for Admin Functionality",
          "description": "Analyze the current schema to identify missing fields, tables, or relationships needed to support administrative functionality, focusing on user management, permissions, and audit trails.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Review common administrative requirements: user roles, permissions, status flags, audit trails, etc.\n2. Compare these requirements against the current schema to identify gaps\n3. Document missing fields needed in existing tables (e.g., is_admin, role_id, status)\n4. Identify new tables that may be needed (e.g., roles, permissions, admin_logs)\n5. Document missing relationships between existing and potentially new tables\n6. Prioritize the identified gaps based on importance for admin functionality\n7. Consider data migration implications for any proposed changes\n\nTesting approach:\n- Create user stories for admin functionality and verify the identified schema can support them\n- Review findings with stakeholders to validate the completeness of the gap analysis",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Create Schema Enhancement Recommendations Document",
          "description": "Compile a comprehensive recommendations document that outlines proposed schema changes, additions, and modifications needed to support the admin system.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Compile findings from all previous subtasks into a cohesive document\n2. Create SQL scripts for recommended schema changes (new tables, altered tables, new fields)\n3. Document potential impacts of schema changes on existing functionality\n4. Provide recommendations for handling data migration for any schema changes\n5. Include the ERD from subtask 3 with annotations showing proposed changes\n6. Document recommended changes to views and functions based on schema modifications\n7. Include a section on security considerations for admin data\n8. Create an implementation timeline and dependency chart for the recommended changes\n\nTesting approach:\n- Review recommendations with database administrators and developers\n- Validate that all identified gaps from subtask 4 are addressed\n- Test proposed SQL scripts in a development environment to verify syntax and functionality",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 6,
          "title": "Document Implemented Schema Enhancements",
          "description": "Document the schema enhancements that have been implemented in the database using Supabase migrations.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implementation steps:\n1. Document the administrative fields added to unified_profiles\n2. Document the new tables created for user notes, admin audit logging, and user activity tracking\n3. Document the search optimization implemented with trigram indexes\n4. Document the unified purchase history view\n5. Document the helper functions implemented for admin operations\n6. Update the ProjectDocs/admin-user-schema-audit.md with the implemented enhancements\n7. Create a section comparing the recommended changes with what was actually implemented\n8. Document any deviations from the original recommendations and the rationale behind them\n\nTesting approach:\n- Verify that all implemented changes are properly documented\n- Confirm that the documentation accurately reflects the current state of the database\n- Review the documentation with stakeholders to ensure clarity and completeness",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Enhance Data Model with Admin-Required Fields",
      "description": "Implement additional tables and fields required for administrative functionality based on the audit findings.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create migration scripts for Supabase to add: 1) admin_audit_log table for tracking administrative actions, 2) user_notes table for administrative annotations, 3) additional fields to unified_profiles for admin-specific flags and metadata. Implement proper foreign key relationships and indexes for performance. Create TypeScript interfaces for all enhanced data models to ensure type safety throughout the application.",
      "testStrategy": "Execute migrations in development environment, verify table structure matches design, and test basic CRUD operations on new tables. Create sample data to validate relationships."
    },
    {
      "id": 3,
      "title": "Develop Data Access Layer for Admin Operations",
      "description": "Create server-side functions and optimized SQL queries for common administrative data operations.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Implement a set of TypeScript functions that handle data access for admin operations including: 1) paginated user queries with filtering, 2) detailed user profile retrieval with related data, 3) audit logging functions, 4) user update operations. Use Supabase client with proper error handling and optimize queries for performance. Implement caching strategies where appropriate for frequently accessed data.",
      "testStrategy": "Create unit tests for each data access function, testing both success paths and error handling. Benchmark query performance against requirements (2-3 second load times)."
    },
    {
      "id": 4,
      "title": "Create Basic Admin Layout and Navigation",
      "description": "Implement the admin interface layout, navigation structure, and authentication guards.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create a layout component for the admin area at /admin using Next.js App Router. Implement navigation sidebar with links to users and future admin sections. Add authentication middleware to protect all admin routes, ensuring only users with admin role can access these pages. Use Shadcn UI components for consistent styling and implement responsive design that works across all device sizes.",
      "testStrategy": "Test authentication guards by attempting access with different user roles. Verify responsive behavior across multiple device sizes. Ensure keyboard navigation and screen reader accessibility."
    },
    {
      "id": 5,
      "title": "Implement User List View with Pagination",
      "description": "Create the responsive data table at /admin/users with basic pagination functionality.",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "high",
      "details": "Most of the implementation for the /admin/users page has been completed, including:\n\n1. A server component that fetches paginated user data using our data access layer\n2. A responsive data table using Shadcn UI components showing key user information\n3. Advanced filtering capabilities (status, acquisition source, transaction history, date ranges)\n4. Pagination controls with URL parameter state persistence\n5. Loading states and error handling\n6. Quick action buttons for viewing and editing user details\n\nRemaining work focuses on performance optimization and responsive testing to ensure the implementation meets requirements across all device sizes.",
      "testStrategy": "Verify that the implementation meets the 2-second initial load requirement across various network conditions. Test pagination with different page sizes to ensure consistent performance. Validate responsive behavior across device sizes (mobile, tablet, desktop) to confirm usability on all screen dimensions. Verify that all implemented features (filtering, sorting, pagination, quick actions) work correctly across devices.",
      "subtasks": [
        {
          "id": "5.1",
          "title": "Performance optimization",
          "description": "Analyze and optimize the current implementation to ensure it meets the 2-second initial load requirement. This may include implementing data caching strategies, optimizing database queries, or adding virtualization for large data sets.",
          "status": "done"
        },
        {
          "id": "5.2",
          "title": "Cross-device responsive testing",
          "description": "Test the user list view across multiple device sizes (mobile, tablet, desktop) to ensure the responsive design works correctly. Verify that all functionality remains accessible and usable regardless of screen size.",
          "status": "done"
        },
        {
          "id": "5.3",
          "title": "Performance testing documentation",
          "description": "Document performance test results showing that the implementation meets the 2-second initial load requirement under various conditions (different page sizes, filter combinations, etc.).",
          "status": "done"
        }
      ]
    },
    {
      "id": 6,
      "title": "Add Search, Filtering and Sorting to User List",
      "description": "Enhance the user list with robust search capabilities, advanced filtering, and column sorting.",
      "status": "in-progress",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "The user list has been enhanced with column sorting functionality and improved filtering UI. Completed work includes: (1) Column sorting with visual indicators for sort direction and URL parameter reflection, (2) Enhanced filtering UI with toggle functionality and fixed parameter/TypeScript issues, (3) Improved UX with cleaner UI and responsive design. Next steps include implementing advanced search functionality with typeahead suggestions and field-specific search capabilities. All implementations follow Next.js best practices with proper separation of client and server components.",
      "testStrategy": "Test search with partial matches and special characters. Verify all filters work correctly in combination. Test sorting on different columns and ensure visual indicators match the current sort state. Ensure URL parameters correctly reflect all filter and sort states. Test responsive design across various screen sizes.",
      "subtasks": [
        {
          "id": "6.1",
          "title": "Implement column sorting functionality",
          "status": "done",
          "description": "Added sort functionality to all relevant columns in the user table with visual indicators (arrows) for sort direction. Ensured sort state is reflected in URL parameters."
        },
        {
          "id": "6.2",
          "title": "Enhance filtering UI",
          "status": "done",
          "description": "Added a toggle button to show/hide filters. Fixed parameter name issues in the filter component and TypeScript errors with the date picker components."
        },
        {
          "id": "6.3",
          "title": "Improve user experience",
          "status": "done",
          "description": "Removed duplicate search functionality for a cleaner UI. Ensured responsive design for all screen sizes. Fixed build errors by properly separating client and server components."
        },
        {
          "id": "6.4",
          "title": "Implement advanced search functionality",
          "status": "todo",
          "description": "Add typeahead suggestions to the search input to help users find what they're looking for more quickly. Implement field-specific search capabilities allowing users to search by specific attributes."
        },
        {
          "id": "6.5",
          "title": "Conduct comprehensive testing",
          "status": "todo",
          "description": "Test all implemented features in combination, including sorting, filtering, and search. Verify URL parameters correctly reflect all states and can be shared. Test across different browsers and screen sizes."
        }
      ]
    },
    {
      "id": 7,
      "title": "Create User Detail View Framework",
      "description": "Build the basic structure for the comprehensive user profile at /admin/users/[id].",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "high",
      "details": "Implement the user detail page at /admin/users/[id] with a tabbed interface using Shadcn UI tabs component. Create the basic layout with sections for personal details, purchase history, enrollments, and activity tracking. Fetch core user data and implement navigation between tabs that preserves state. Add breadcrumb navigation back to the user list and implement proper loading and error states.",
      "testStrategy": "Test navigation between tabs, verify data loading for different user IDs, and ensure the UI matches design specifications. Test error handling with invalid user IDs."
    },
    {
      "id": 8,
      "title": "Implement User Profile and Editing Functionality",
      "description": "Complete the personal details tab with editable fields and validation.",
      "status": "done",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Enhance the personal details tab with all user profile information. Implement editable fields using Shadcn UI form components with client-side validation. Create server actions for securely updating user data with proper error handling. Add confirmation workflows for sensitive changes and implement optimistic updates for better UX. Ensure all edits are logged to the admin_audit_log table.",
      "testStrategy": "Test form validation with valid and invalid inputs. Verify server actions correctly update the database. Test audit logging for all edit operations. Ensure error messages are clear and helpful."
    },
    {
      "id": 9,
      "title": "Develop Purchase History and Enrollment Sections",
      "description": "Implement the purchase history and enrollment tabs in the user detail view.",
      "status": "done",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Create the purchase history tab showing all transactions from shopify_orders and shopify_order_items with product details and payment information. Implement the enrollment tab displaying current and past course enrollments with status indicators. Add filtering and sorting capabilities within each tab. Include action buttons for managing enrollments and viewing order details. Ensure efficient data loading with pagination for users with extensive history.",
      "testStrategy": "Test with users having various purchase and enrollment patterns. Verify all data is displayed correctly and actions work as expected. Test pagination for users with large datasets."
    },
    {
      "id": 10,
      "title": "Create Activity and Engagement Tracking",
      "description": "Implement the activity tracking tab with login history and content access statistics.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "low",
      "details": "Develop the activity tracking tab showing login history, content access patterns, and engagement metrics. Create visualizations using a charting library to display trends over time. Implement filtering by date ranges and activity types. Add export functionality for activity data. Ensure efficient data loading and aggregation for users with extensive activity history.",
      "testStrategy": "Test with users having various activity patterns. Verify visualizations render correctly and are responsive. Test date filtering and exports for accuracy."
    },
    {
      "id": 11,
      "title": "Implement Administrative Tools and Access Management",
      "description": "Build administrative tooling including password reset, account status management, and access controls.",
      "status": "done",
      "dependencies": [
        8
      ],
      "priority": "high",
      "details": "Create an administrative tools tab with functionality for password reset, account status changes (active/inactive/suspended), and feature access management. Implement secure server actions for these operations with appropriate confirmation workflows. Add detailed logging to admin_audit_log for all administrative actions. Include email notification options for relevant actions (e.g., password reset).",
      "testStrategy": "Test each administrative action for proper execution and audit logging. Verify confirmation workflows prevent accidental changes. Test email notifications if implemented."
    },
    {
      "id": 12,
      "title": "Develop Account Reconciliation Interface",
      "description": "Create the interface for searching and linking user records across different systems.",
      "status": "done",
      "dependencies": [
        8
      ],
      "priority": "medium",
      "details": "Implement an account reconciliation tab that allows searching for potentially related user accounts across systems. Create UI for manually linking accounts with confirmation workflow. Develop data comparison views to help identify matching accounts. Implement merge functionality with clear preview of results and conflict resolution. Ensure all reconciliation actions are logged for audit purposes.",
      "testStrategy": "Test search functionality with various criteria. Verify linking and merging operations maintain data integrity. Test conflict resolution scenarios and ensure audit logging captures all actions."
    },
    {
      "id": 13,
      "title": "Create User Analytics Dashboard",
      "description": "Design and implement the user analytics dashboard showing acquisition trends and engagement metrics.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "low",
      "details": "Develop a user analytics dashboard at /admin/analytics with visualizations for user acquisition trends, engagement metrics, and cohort analysis. Implement filtering by date ranges and user segments. Create summary cards for key metrics and detailed charts for trends. Use a charting library compatible with Next.js and ensure responsive design for all visualizations.",
      "testStrategy": "Test dashboard with various date ranges and user segments. Verify all visualizations render correctly and are responsive. Benchmark performance against requirements."
    },
    {
      "id": 14,
      "title": "Implement Reporting and Export Functionality",
      "description": "Build reporting capabilities and data export functionality in common formats.",
      "status": "pending",
      "dependencies": [
        13
      ],
      "priority": "low",
      "details": "Add export functionality to the analytics dashboard and user list for common formats (CSV, Excel). Implement custom report generation with selectable fields and filtering criteria. Create scheduled report functionality with email delivery options. Ensure exports include proper headers and formatting for readability. Add progress indicators for large exports.",
      "testStrategy": "Test exports in different formats for accuracy and formatting. Verify custom reports generate correctly with various criteria. Test scheduled reports if implemented."
    },
    {
      "id": 15,
      "title": "Implement Security Enhancements and Final Testing",
      "description": "Add security features, conduct comprehensive testing, and prepare for deployment.",
      "status": "in-progress",
      "dependencies": [
        11,
        12,
        14
      ],
      "priority": "high",
      "details": "Implement role-based access control for different administrative functions. Add rate limiting for sensitive operations. Conduct security review of all admin endpoints. Implement comprehensive error handling and logging. Perform end-to-end testing of all user flows. Optimize performance for any slow operations identified during testing. Create documentation for administrators using the system.",
      "testStrategy": "Conduct penetration testing focusing on admin functions. Verify all user flows work end-to-end. Test error scenarios and recovery. Measure performance against requirements and optimize as needed."
    },
    {
      "id": 16,
      "title": "Postmark Account Setup and Configuration",
      "description": "Create and configure Postmark account with proper authentication settings for the Graceful Homeschooling platform.",
      "details": "1. Sign up for a Postmark account\n2. Configure sender signatures for all required domains\n3. Verify domain ownership through DNS records\n4. Set up SPF, DKIM, and DMARC records for improved deliverability\n5. Create server instances for different environments (development, staging, production)\n6. Generate and securely store API tokens\n7. Configure initial bounce handling and webhook endpoints\n8. Set up message streams for different email types (transactional, marketing, etc.)\n9. Test basic connectivity with Postmark API",
      "testStrategy": "1. Verify domain authentication status in Postmark dashboard\n2. Confirm SPF, DKIM, and DMARC records are properly configured using DNS lookup tools\n3. Send test emails through Postmark API to verify connectivity\n4. Validate webhook endpoints are properly receiving test events",
      "priority": "high",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Postmark Account and Verify Domain",
          "description": "Sign up for a Postmark account and verify domain ownership for the Graceful Homeschooling platform.",
          "dependencies": [],
          "details": "1. Create a new Postmark account using company email\n2. Add the primary domain for Graceful Homeschooling\n3. Generate and add the required DNS TXT records to verify domain ownership\n4. Document account credentials in the secure password manager",
          "status": "done",
          "testStrategy": "Verify domain status shows as 'confirmed' in the Postmark dashboard"
        },
        {
          "id": 2,
          "title": "Configure Email Authentication Records",
          "description": "Set up SPF, DKIM, and DMARC records to improve email deliverability and prevent spoofing.",
          "dependencies": [
            1
          ],
          "details": "1. Generate SPF record with Postmark's recommended settings\n2. Create DKIM keys in Postmark and add corresponding DNS records\n3. Implement DMARC policy with monitoring settings\n4. Wait for DNS propagation and verify all records are properly configured",
          "status": "done",
          "testStrategy": "Use Postmark's built-in authentication checker and third-party tools like MXToolbox to verify proper configuration"
        },
        {
          "id": 3,
          "title": "Create Server Instances for Different Environments",
          "description": "Set up separate Postmark server instances for development, staging, and production environments.",
          "dependencies": [
            1
          ],
          "details": "1. Create three server instances in Postmark: 'graceful-dev', 'graceful-staging', and 'graceful-prod'\n2. Configure appropriate settings for each environment (stricter for production)\n3. Document the server IDs and purposes in the project documentation\n4. Set appropriate rate limits for each environment",
          "status": "done",
          "testStrategy": "Verify all three servers appear in the Postmark dashboard with correct configurations"
        },
        {
          "id": 4,
          "title": "Generate and Store API Tokens",
          "description": "Generate API tokens for each environment and securely store them for application use.",
          "dependencies": [
            3
          ],
          "details": "1. Generate server API tokens for each environment\n2. Create test tokens for development purposes\n3. Store tokens in the project's secure environment variables\n4. Update the application's configuration files to use the appropriate tokens per environment\n5. Document token rotation procedures",
          "status": "done",
          "testStrategy": "Verify tokens can be used to successfully authenticate with the Postmark API from each environment"
        },
        {
          "id": 5,
          "title": "Configure Message Streams and Templates",
          "description": "Set up message streams for different email types and create initial email templates.",
          "dependencies": [
            3
          ],
          "details": "1. Create separate streams for transactional and marketing emails\n2. Configure appropriate settings for each stream (open tracking, click tracking, etc.)\n3. Create basic email templates for common notifications (welcome, password reset, etc.)\n4. Set up template variables and test rendering",
          "status": "done",
          "testStrategy": "Send test emails using each stream and verify they are properly categorized in the Postmark dashboard"
        },
        {
          "id": 6,
          "title": "Implement Bounce Handling and Webhook Integration",
          "description": "Configure bounce handling and set up webhook endpoints to process email events.",
          "dependencies": [
            4,
            5
          ],
          "details": "1. Create webhook endpoints in the application to receive Postmark events\n2. Configure Postmark to send bounce, delivery, and engagement events to these endpoints\n3. Implement logic to process bounces and update user email status\n4. Set up monitoring for bounce rates and delivery issues\n5. Test the complete email sending and event handling flow\n<info added on 2025-05-08T06:38:45.386Z>\n1. Create webhook endpoints in the application to receive Postmark events\n2. Configure Postmark to send bounce, delivery, and engagement events to these endpoints\n3. Implement logic to process bounces and update user email status\n4. Set up monitoring for bounce rates and delivery issues\n5. Test the complete email sending and event handling flow\n\nThis subtask has been relocated and is now being tracked as Subtask 34.1 under 'Phase 1: Solidify Core Email Infrastructure (Postmark & Unlayer)' (Task 34). All further updates, progress tracking, and implementation details for bounce handling and webhook integration should be referenced in the new subtask location.\n</info added on 2025-05-08T06:38:45.386Z>",
          "status": "cancelled",
          "testStrategy": "Simulate bounces using Postmark's testing tools and verify the application correctly processes the webhook notifications"
        }
      ]
    },
    {
      "id": 17,
      "title": "Postmark API Client Implementation",
      "description": "Develop a reusable API client for interacting with Postmark services, including error handling and logging.",
      "details": "1. Create a PostmarkService class that encapsulates all Postmark API interactions\n2. Implement methods for sending transactional emails\n3. Implement methods for sending batch emails\n4. Implement methods for template management\n5. Add robust error handling with appropriate retry logic\n6. Implement logging for all API interactions\n7. Create environment-specific configurations\n8. Add rate limiting protection\n9. Implement helper methods for common email operations\n\n```typescript\n// Example PostmarkService implementation\nclass PostmarkService {\n  private client: PostmarkClient;\n  \n  constructor(apiKey: string) {\n    this.client = new PostmarkClient(apiKey);\n  }\n  \n  async sendTransactionalEmail(options: EmailOptions): Promise<SendResult> {\n    try {\n      const response = await this.client.sendEmail({\n        From: options.from,\n        To: options.to,\n        Subject: options.subject,\n        HtmlBody: options.htmlBody,\n        TextBody: options.textBody,\n        MessageStream: 'outbound',\n        // Additional options as needed\n      });\n      \n      logger.info('Email sent successfully', { messageId: response.MessageID });\n      return { success: true, messageId: response.MessageID };\n    } catch (error) {\n      logger.error('Failed to send email', { error, options });\n      // Implement retry logic if appropriate\n      return { success: false, error };\n    }\n  }\n  \n  // Additional methods for other Postmark operations\n}\n```",
      "testStrategy": "1. Write unit tests for each API client method using mocked Postmark responses\n2. Test error handling with simulated API failures\n3. Verify logging captures appropriate information\n4. Test retry logic with forced failures\n5. Create integration tests that send actual emails to test accounts\n6. Verify rate limiting behavior works as expected",
      "priority": "high",
      "dependencies": [
        16
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "MJML Email Template System",
      "description": "This task is deprecated. The MJML-based email template system has been superseded by a direct HTML approach (Task 31) and the integration of the Unlayer email editor (Task 32).",
      "status": "cancelled",
      "dependencies": [
        16
      ],
      "priority": "high",
      "details": "**DEPRECATED APPROACH**\n\nThis MJML-based email template system has been replaced by:\n1. A direct HTML approach (see Task 31)\n2. The integration of Unlayer email editor (see Task 32) for a more user-friendly template management experience\n\nAll email template creation and management will now use Unlayer instead of the MJML approach described below.\n\n**Original Implementation (No Longer Used):**\n\n1. Install and configure MJML processing libraries ✅\n2. Create base MJML template with Graceful Homeschooling branding (Purple #b08ba5, Pink #f1b5bc, Blue #9ac5d9) ✅\n3. Implement typography standards (Inter for body text, Playfair Display for headings) ✅\n4. Design responsive layouts that work across all email clients ✅\n5. Create component library for common email elements (headers, footers, buttons, etc.) ✅\n6. Implement variable substitution system for personalization ✅\n7. Create utility functions to convert MJML to HTML ✅\n8. Set up template storage in the database ✅\n9. Implement Monaco-based code editor in admin interface for template editing ✅\n10. Create template preview functionality in admin interface ✅\n11. Develop specialized templates for different email types:\n    - Authentication emails (verification, password reset) ✅\n    - Transactional emails (receipts, confirmations) ✅\n    - Marketing/newsletter templates ✅\n\n```typescript\n// Example MJML template processing\nimport mjml2html from 'mjml';\n\nconst baseTemplate = `\n<mjml>\n  <mj-head>\n    <mj-attributes>\n      <mj-all font-family=\"Inter, Arial, sans-serif\" />\n      <mj-text font-weight=\"400\" font-size=\"16px\" color=\"#000000\" line-height=\"24px\" />\n      <mj-section padding=\"0px\" />\n    </mj-attributes>\n    <mj-style>\n      h1, h2, h3, h4 { font-family: 'Playfair Display', Georgia, serif; }\n      .gh-primary { color: #b08ba5; }\n      .gh-secondary { color: #f1b5bc; }\n      .gh-tertiary { color: #9ac5d9; }\n    </mj-style>\n  </mj-head>\n  <mj-body background-color=\"#ffffff\">\n    <!-- Header -->\n    <mj-section background-color=\"#b08ba5\" padding=\"20px\">\n      <mj-column>\n        <mj-image width=\"200px\" src=\"{{logoUrl}}\" alt=\"Graceful Homeschooling\" />\n      </mj-column>\n    </mj-section>\n    \n    <!-- Content -->\n    <mj-section padding=\"20px\">\n      <mj-column>\n        <mj-text>\n          {{content}}\n        </mj-text>\n      </mj-column>\n    </mj-section>\n    \n    <!-- Footer -->\n    <mj-section background-color=\"#f6f6f6\" padding=\"20px\">\n      <mj-column>\n        <mj-text align=\"center\" font-size=\"12px\">\n          &copy; {{year}} Graceful Homeschooling. All rights reserved.\n          <br />\n          {{#if showUnsubscribe}}\n          <a href=\"{{unsubscribeUrl}}\">Unsubscribe</a>\n          {{/if}}\n        </mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n`;\n\nfunction renderTemplate(template, variables) {\n  // Replace variables in template\n  const processedTemplate = Object.entries(variables).reduce(\n    (result, [key, value]) => result.replace(new RegExp(`{{${key}}}`, 'g'), value),\n    template\n  );\n  \n  // Convert MJML to HTML\n  const { html, errors } = mjml2html(processedTemplate);\n  \n  if (errors && errors.length) {\n    console.error('MJML processing errors:', errors);\n  }\n  \n  return html;\n}\n```",
      "testStrategy": "**DEPRECATED TESTING APPROACH**\n\nThis testing strategy is no longer applicable as the MJML approach has been replaced by Unlayer (Task 32) and direct HTML (Task 31). Please refer to those tasks for current testing strategies.\n\nOriginal testing strategy (for reference only):\n\n1. Create visual regression tests for email templates ✅\n2. Test templates across different email clients using Email on Acid or Litmus ✅\n3. Verify responsive behavior on mobile, tablet, and desktop viewports ✅\n4. Test variable substitution with different data sets ✅\n5. Validate HTML output meets email client compatibility standards ✅\n6. Test rendering performance with large templates ✅\n7. Test Monaco editor functionality in the admin interface\n8. Verify template preview accurately represents final email output\n9. Test template saving and loading from database\n10. Verify specialized templates (authentication, transactional, etc.) meet their specific requirements",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Supabase Auth Integration with Postmark",
      "description": "Configure Supabase to use Postmark for authentication emails and customize templates for email confirmation, password reset, and magic links.",
      "details": "1. Update Supabase configuration to use Postmark as the email provider\n2. Create custom email templates for:\n   - Email confirmation\n   - Password reset\n   - Magic link authentication\n3. Implement secure credential management to replace \"graceful2025\" default pattern\n4. Configure email sender identity for authentication emails\n5. Set up proper redirect URLs for authentication flows\n6. Implement custom handlers for authentication events\n7. Add logging for authentication email events\n\n```typescript\n// Example Supabase configuration for Postmark\nimport { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Client for public operations\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Admin client for server-side operations\nexport const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);\n\n// Configure email templates via Supabase dashboard or API\nasync function configureAuthEmailTemplates() {\n  // This would typically be done through the Supabase dashboard\n  // or using their management API\n  \n  // Example of how to update auth email templates programmatically\n  // (if supported by Supabase API)\n  await supabaseAdmin.auth.updateConfig({\n    email_templates: {\n      invite: {\n        subject: 'Join Graceful Homeschooling',\n        content: '...' // MJML template converted to HTML\n      },\n      confirmation: {\n        subject: 'Confirm Your Graceful Homeschooling Account',\n        content: '...' // MJML template converted to HTML\n      },\n      recovery: {\n        subject: 'Reset Your Graceful Homeschooling Password',\n        content: '...' // MJML template converted to HTML\n      },\n      magic_link: {\n        subject: 'Your Magic Link to Graceful Homeschooling',\n        content: '...' // MJML template converted to HTML\n      }\n    }\n  });\n}\n```",
      "testStrategy": "1. Test complete authentication flows (registration, password reset, magic link)\n2. Verify emails are sent through Postmark with correct templates\n3. Test email deliverability to various email providers\n4. Validate all links in authentication emails work correctly\n5. Test secure credential management with various password patterns\n6. Verify proper error handling for authentication failures",
      "priority": "high",
      "dependencies": [
        17,
        18
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "User Tagging and Segmentation System",
      "description": "Implement a tagging system for categorizing users and create predefined segments for common user groups to enable targeted email communications.",
      "status": "cancelled",
      "dependencies": [
        17
      ],
      "priority": "medium",
      "details": "1. Design database schema for user tags and segments\n2. Create API endpoints for tag management\n3. Implement tag assignment logic for users\n4. Develop predefined segments based on common criteria:\n   - Enrollment status\n   - Purchase history\n   - Activity level\n   - Content preferences\n5. Build filtering logic for combining tags and other user attributes\n6. Create segment preview and size estimation tools\n7. Implement batch operations for tag management\n\n```sql\n-- Example schema for tags and segments\n\n-- Tags table\nCREATE TABLE user_tags (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- User-tag association table\nCREATE TABLE user_tag_assignments (\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,\n  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  PRIMARY KEY (user_id, tag_id)\n);\n\n-- Segments table\nCREATE TABLE user_segments (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  filter_criteria JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Example filter criteria JSON structure:\n-- {\n--   \"operator\": \"AND\",\n--   \"conditions\": [\n--     { \"type\": \"tag\", \"operator\": \"has\", \"value\": \"tag_id_1\" },\n--     { \"type\": \"tag\", \"operator\": \"not_has\", \"value\": \"tag_id_2\" },\n--     { \"type\": \"profile\", \"field\": \"enrollment_status\", \"operator\": \"equals\", \"value\": \"active\" },\n--     { \"type\": \"activity\", \"operator\": \"last_active\", \"value\": \"30d\" }\n--   ]\n-- }\n```\n\n```typescript\n// Example segment evaluation function\nasync function evaluateSegment(segmentId: string): Promise<string[]> {\n  // Fetch segment definition\n  const { data: segment } = await supabase\n    .from('user_segments')\n    .select('*')\n    .eq('id', segmentId)\n    .single();\n    \n  if (!segment) throw new Error('Segment not found');\n  \n  // Build SQL query based on filter criteria\n  let query = supabase.from('users').select('id');\n  \n  // Apply filters based on segment.filter_criteria\n  // This is a simplified example - real implementation would be more complex\n  const criteria = segment.filter_criteria;\n  \n  if (criteria.operator === 'AND') {\n    for (const condition of criteria.conditions) {\n      if (condition.type === 'tag' && condition.operator === 'has') {\n        query = query.in('id', (sb) => \n          sb.from('user_tag_assignments')\n            .select('user_id')\n            .eq('tag_id', condition.value)\n        );\n      }\n      // Add other condition types...\n    }\n  }\n  \n  // Execute query and return user IDs\n  const { data: users, error } = await query;\n  \n  if (error) throw error;\n  return users.map(user => user.id);\n}\n```",
      "testStrategy": "1. Unit test tag assignment and removal functionality\n2. Test segment evaluation with various filter criteria\n3. Benchmark performance with large user datasets\n4. Verify segment size estimation accuracy\n5. Test batch operations with different tag combinations\n6. Validate database integrity with concurrent operations",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Email Template Management Interface",
      "description": "This task is deprecated. The Email Template Management Interface functionality has been fully addressed by the integration of the Unlayer email editor (see Task 32).",
      "status": "cancelled",
      "dependencies": [
        18
      ],
      "priority": "low",
      "details": "This task has been superseded by the implementation of the Unlayer email editor, which provides comprehensive template management capabilities including:\n\n1. Visual WYSIWYG editor for template editing\n2. Template management UI with listing, search, and filtering\n3. Template creation workflow\n4. Template preview functionality\n5. Variable management for personalization\n6. Template versioning and organization features\n\nPlease refer to Task 32 and the associated documentation at `ProjectDocs/Build_Notes/unlayer-email-editor-integration_phase-1_implementation.md` for details on the implemented solution.\n\nThe original implementation plan included:\n1. ~~Design template management UI with listing, search, and filtering~~\n2. ~~Implement template creation workflow~~\n3. ~~Create visual WYSIWYG editor for template editing~~\n4. ~~Add MJML code editor for advanced users~~\n5. ~~Implement template versioning and history~~\n6. ~~Add template preview functionality~~\n7. ~~Create template categories for organization~~\n8. ~~Implement template duplication and templating~~\n9. ~~Add variable management for personalization~~\n\nAll these requirements have been addressed by the Unlayer integration.",
      "testStrategy": "No testing required for this task as it has been deprecated. Testing for email template management functionality should be performed as part of Task 32 (Unlayer email editor integration).",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Campaign Management System",
      "description": "Develop a campaign management interface with scheduling capabilities, recipient targeting, and automation for recurring emails.",
      "status": "cancelled",
      "dependencies": [
        20,
        "32"
      ],
      "priority": "medium",
      "details": "1. Design campaign management UI with listing, filtering, and status views\n2. Implement campaign creation workflow\n3. Create recipient selection interface using segments and tags\n4. Build scheduling functionality with timezone support\n5. Implement campaign preview and testing\n6. Create campaign duplication functionality\n7. Develop automation rules for recurring emails\n8. Add A/B testing capabilities\n9. Implement campaign status tracking\n\n```typescript\n// Example campaign creation component\nimport React, { useState } from 'react';\nimport { supabase } from '../lib/supabaseClient';\nimport { SegmentSelector } from '../components/SegmentSelector';\nimport { TemplateSelector } from '../components/TemplateSelector';\nimport { DateTimePicker } from '../components/DateTimePicker';\n\nconst CampaignCreator = () => {\n  const [campaign, setCampaign] = useState({\n    name: '',\n    subject: '',\n    from_name: 'Graceful Homeschooling',\n    from_email: 'hello@gracefulhomeschooling.com',\n    template_id: null,\n    segment_id: null,\n    scheduled_for: null,\n    is_recurring: false,\n    recurrence_pattern: null\n  });\n  \n  const [step, setStep] = useState(1); // Multi-step form\n  \n  const handleChange = (field, value) => {\n    setCampaign(prev => ({ ...prev, [field]: value }));\n  };\n  \n  const handleSegmentChange = (segmentId) => {\n    handleChange('segment_id', segmentId);\n  };\n  \n  const handleTemplateChange = (templateId) => {\n    handleChange('template_id', templateId);\n  };\n  \n  const handleScheduleChange = (date) => {\n    handleChange('scheduled_for', date);\n  };\n  \n  const toggleRecurring = () => {\n    handleChange('is_recurring', !campaign.is_recurring);\n  };\n  \n  const saveCampaign = async () => {\n    try {\n      const { data, error } = await supabase\n        .from('email_campaigns')\n        .insert([\n          {\n            name: campaign.name,\n            subject: campaign.subject,\n            from_name: campaign.from_name,\n            from_email: campaign.from_email,\n            template_id: campaign.template_id,\n            segment_id: campaign.segment_id,\n            scheduled_for: campaign.scheduled_for,\n            is_recurring: campaign.is_recurring,\n            recurrence_pattern: campaign.recurrence_pattern,\n            status: 'draft',\n            created_at: new Date()\n          }\n        ]);\n        \n      if (error) throw error;\n      \n      // Handle success - redirect to campaign detail or list\n    } catch (error) {\n      console.error('Error creating campaign:', error);\n    }\n  };\n  \n  const renderStepContent = () => {\n    switch (step) {\n      case 1:\n        return (\n          <div className=\"campaign-details\">\n            <h3>Campaign Details</h3>\n            <div className=\"form-group\">\n              <label>Campaign Name</label>\n              <input\n                type=\"text\"\n                value={campaign.name}\n                onChange={(e) => handleChange('name', e.target.value)}\n              />\n            </div>\n            <div className=\"form-group\">\n              <label>Subject Line</label>\n              <input\n                type=\"text\"\n                value={campaign.subject}\n                onChange={(e) => handleChange('subject', e.target.value)}\n              />\n            </div>\n            {/* Additional fields */}\n          </div>\n        );\n      case 2:\n        return (\n          <div className=\"campaign-content\">\n            <h3>Email Content</h3>\n            <TemplateSelector\n              selectedTemplateId={campaign.template_id}\n              onSelect={handleTemplateChange}\n            />\n          </div>\n        );\n      case 3:\n        return (\n          <div className=\"campaign-audience\">\n            <h3>Select Audience</h3>\n            <SegmentSelector\n              selectedSegmentId={campaign.segment_id}\n              onSelect={handleSegmentChange}\n            />\n          </div>\n        );\n      case 4:\n        return (\n          <div className=\"campaign-schedule\">\n            <h3>Schedule Campaign</h3>\n            <div className=\"form-group\">\n              <label>Send Date and Time</label>\n              <DateTimePicker\n                value={campaign.scheduled_for}\n                onChange={handleScheduleChange}\n              />\n            </div>\n            <div className=\"form-group\">\n              <label>\n                <input\n                  type=\"checkbox\"\n                  checked={campaign.is_recurring}\n                  onChange={toggleRecurring}\n                />\n                Make this a recurring campaign\n              </label>\n            </div>\n            {campaign.is_recurring && (\n              <div className=\"recurrence-options\">\n                {/* Recurrence pattern options */}\n              </div>\n            )}\n          </div>\n        );\n      default:\n        return null;\n    }\n  };\n  \n  return (\n    <div className=\"campaign-creator\">\n      <h2>Create New Campaign</h2>\n      \n      <div className=\"step-indicator\">\n        {/* Step indicators */}\n      </div>\n      \n      {renderStepContent()}\n      \n      <div className=\"form-actions\">\n        {step > 1 && (\n          <button onClick={() => setStep(step - 1)}>Previous</button>\n        )}\n        \n        {step < 4 ? (\n          <button onClick={() => setStep(step + 1)}>Next</button>\n        ) : (\n          <button onClick={saveCampaign}>Create Campaign</button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CampaignCreator;\n```",
      "testStrategy": "1. Test campaign creation workflow with various configurations\n2. Verify scheduling functionality with different timezones\n3. Test recipient targeting with different segments\n4. Validate campaign preview functionality\n5. Test campaign duplication\n6. Verify recurring campaign setup and execution\n7. Test A/B testing configuration\n8. Validate campaign status updates throughout lifecycle",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Email Sending Service Implementation",
      "description": "Develop the core email sending service that handles different types of emails (transactional, marketing, educational) using Postmark's API.",
      "details": "1. Create a comprehensive email sending service\n2. Implement different sending methods for various email types\n3. Add template rendering with variable substitution\n4. Implement batch sending capabilities\n5. Add rate limiting and throttling\n6. Create retry mechanism for failed sends\n7. Implement logging and monitoring\n8. Add support for attachments and inline images\n\n```typescript\n// Example email sending service\nimport { PostmarkClient } from 'postmark';\nimport { renderTemplate } from './templateRenderer';\nimport { logger } from './logger';\n\nexport class EmailService {\n  private client: PostmarkClient;\n  \n  constructor(apiKey: string) {\n    this.client = new PostmarkClient(apiKey);\n  }\n  \n  /**\n   * Send a transactional email using a template\n   */\n  async sendTransactionalEmail(options: {\n    to: string;\n    subject: string;\n    templateId: string;\n    templateData: Record<string, any>;\n    from?: string;\n    replyTo?: string;\n    attachments?: Array<{ name: string, content: string, contentType: string }>;\n    messageStream?: string;\n  }) {\n    const {\n      to,\n      subject,\n      templateId,\n      templateData,\n      from = 'hello@gracefulhomeschooling.com',\n      replyTo,\n      attachments = [],\n      messageStream = 'outbound'\n    } = options;\n    \n    try {\n      const response = await this.client.sendEmailWithTemplate({\n        From: from,\n        To: to,\n        Subject: subject,\n        TemplateId: templateId,\n        TemplateModel: templateData,\n        ReplyTo: replyTo,\n        MessageStream: messageStream,\n        Attachments: attachments.map(att => ({\n          Name: att.name,\n          Content: att.content,\n          ContentType: att.contentType\n        }))\n      });\n      \n      logger.info('Transactional email sent', {\n        messageId: response.MessageID,\n        to,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: true,\n        messageId: response.MessageID\n      };\n    } catch (error) {\n      logger.error('Failed to send transactional email', {\n        error,\n        to,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: false,\n        error\n      };\n    }\n  }\n  \n  /**\n   * Send a marketing email to multiple recipients\n   */\n  async sendMarketingEmail(options: {\n    recipients: Array<{ email: string, data?: Record<string, any> }>;\n    subject: string;\n    templateId: string;\n    from?: string;\n    messageStream?: string;\n  }) {\n    const {\n      recipients,\n      subject,\n      templateId,\n      from = 'hello@gracefulhomeschooling.com',\n      messageStream = 'broadcast'\n    } = options;\n    \n    try {\n      // Split recipients into batches of 500 (Postmark's limit)\n      const batchSize = 500;\n      const batches = [];\n      \n      for (let i = 0; i < recipients.length; i += batchSize) {\n        batches.push(recipients.slice(i, i + batchSize));\n      }\n      \n      const results = [];\n      \n      for (const batch of batches) {\n        const messages = batch.map(recipient => ({\n          From: from,\n          To: recipient.email,\n          Subject: subject,\n          TemplateId: templateId,\n          TemplateModel: recipient.data || {},\n          MessageStream: messageStream\n        }));\n        \n        const response = await this.client.sendEmailBatch(messages);\n        results.push(...response);\n        \n        // Add a small delay between batches to avoid rate limits\n        if (batches.length > 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      }\n      \n      logger.info('Marketing email batch sent', {\n        recipientCount: recipients.length,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: true,\n        results\n      };\n    } catch (error) {\n      logger.error('Failed to send marketing email batch', {\n        error,\n        recipientCount: recipients.length,\n        subject,\n        templateId\n      });\n      \n      return {\n        success: false,\n        error\n      };\n    }\n  }\n  \n  /**\n   * Send a test email to verify template rendering\n   */\n  async sendTestEmail(options: {\n    to: string;\n    subject: string;\n    templateId: string;\n    templateData: Record<string, any>;\n  }) {\n    return this.sendTransactionalEmail({\n      ...options,\n      subject: `[TEST] ${options.subject}`\n    });\n  }\n}\n```",
      "testStrategy": "1. Unit test each email sending method\n2. Test template rendering with various data sets\n3. Verify batch sending with different recipient counts\n4. Test rate limiting and throttling behavior\n5. Verify retry mechanism for failed sends\n6. Test logging captures appropriate information\n7. Validate attachment handling\n8. Test with different Postmark message streams",
      "priority": "high",
      "dependencies": [
        17,
        18
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Email Webhook Processing",
      "description": "Implement webhook handling for Postmark events to track email engagement metrics like opens, clicks, bounces, and spam reports.",
      "details": "1. Create webhook endpoint for Postmark events\n2. Implement handlers for different event types:\n   - Delivery\n   - Open\n   - Click\n   - Bounce\n   - Spam complaint\n   - Subscription change\n3. Store event data in the database\n4. Implement webhook authentication and validation\n5. Add error handling and retry logic\n6. Create background processing for high-volume events\n7. Implement event aggregation for analytics\n\n```typescript\n// Example webhook handler for Next.js API route\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '../../lib/supabaseClient';\nimport { verifyPostmarkWebhook } from '../../lib/postmarkUtils';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    // Verify webhook signature if Postmark provides one\n    if (!verifyPostmarkWebhook(req)) {\n      return res.status(401).json({ error: 'Invalid webhook signature' });\n    }\n    \n    const event = req.body;\n    \n    // Process different event types\n    switch (event.RecordType) {\n      case 'Delivery':\n        await processDeliveryEvent(event);\n        break;\n      case 'Open':\n        await processOpenEvent(event);\n        break;\n      case 'Click':\n        await processClickEvent(event);\n        break;\n      case 'Bounce':\n        await processBounceEvent(event);\n        break;\n      case 'SpamComplaint':\n        await processSpamComplaintEvent(event);\n        break;\n      case 'SubscriptionChange':\n        await processSubscriptionChangeEvent(event);\n        break;\n      default:\n        console.warn('Unknown event type:', event.RecordType);\n    }\n    \n    return res.status(200).json({ success: true });\n  } catch (error) {\n    console.error('Error processing webhook:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n\nasync function processDeliveryEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'delivery',\n      recipient: event.Recipient,\n      timestamp: new Date(event.DeliveredAt),\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processOpenEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'open',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ReceivedAt),\n      user_agent: event.UserAgent,\n      geo_location: event.Geo,\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processClickEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'click',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ReceivedAt),\n      user_agent: event.UserAgent,\n      geo_location: event.Geo,\n      link_url: event.OriginalLink,\n      raw_event: event\n    }\n  ]);\n}\n\nasync function processBounceEvent(event) {\n  // Insert event record\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'bounce',\n      recipient: event.Recipient,\n      timestamp: new Date(event.BouncedAt),\n      bounce_type: event.Type,\n      bounce_reason: event.Description,\n      raw_event: event\n    }\n  ]);\n  \n  // Update user record for hard bounces\n  if (event.Type === 'HardBounce') {\n    await supabase.from('user_email_preferences')\n      .update({ \n        is_valid_email: false,\n        bounce_reason: event.Description,\n        updated_at: new Date()\n      })\n      .eq('email', event.Recipient);\n  }\n}\n\nasync function processSpamComplaintEvent(event) {\n  // Insert event record\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'spam_complaint',\n      recipient: event.Recipient,\n      timestamp: new Date(event.BouncedAt),\n      raw_event: event\n    }\n  ]);\n  \n  // Update user preferences to opt out\n  await supabase.from('user_email_preferences')\n    .update({ \n      marketing_opt_in: false,\n      updated_at: new Date(),\n      opt_out_reason: 'spam_complaint'\n    })\n    .eq('email', event.Recipient);\n}\n\nasync function processSubscriptionChangeEvent(event) {\n  await supabase.from('email_events').insert([\n    {\n      message_id: event.MessageID,\n      event_type: 'subscription_change',\n      recipient: event.Recipient,\n      timestamp: new Date(event.ChangedAt),\n      subscription_change: event.SuppressionReason,\n      raw_event: event\n    }\n  ]);\n  \n  // Update user preferences based on subscription change\n  await supabase.from('user_email_preferences')\n    .update({ \n      marketing_opt_in: event.SuppressionReason !== 'Unsubscribed',\n      updated_at: new Date(),\n      opt_out_reason: event.SuppressionReason === 'Unsubscribed' ? 'unsubscribe' : null\n    })\n    .eq('email', event.Recipient);\n}\n```",
      "testStrategy": "1. Test webhook endpoint with sample Postmark event payloads\n2. Verify event data is correctly stored in the database\n3. Test webhook authentication and validation\n4. Verify error handling for malformed requests\n5. Test high-volume event processing\n6. Validate user preference updates based on events\n7. Test event aggregation for analytics\n8. Verify webhook endpoint security",
      "priority": "medium",
      "dependencies": [
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Email Analytics Dashboard",
      "description": "Build an analytics dashboard to visualize email performance metrics including opens, clicks, bounces, and engagement over time.",
      "details": "1. Design analytics dashboard UI with key metrics overview\n2. Implement data aggregation for email performance metrics\n3. Create visualizations for:\n   - Open rates\n   - Click-through rates\n   - Bounce rates\n   - Spam complaint rates\n   - Engagement over time\n4. Add filtering by campaign, date range, and email type\n5. Implement drill-down capabilities for detailed analysis\n6. Create exportable reports for stakeholders\n7. Add real-time updates for recent campaigns\n\n```typescript\n// Example analytics data fetching service\nimport { supabase } from '../lib/supabaseClient';\n\nexport async function getEmailAnalytics(filters: {\n  startDate?: Date;\n  endDate?: Date;\n  campaignId?: string;\n  emailType?: string;\n}) {\n  const {\n    startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Default to last 30 days\n    endDate = new Date(),\n    campaignId,\n    emailType\n  } = filters;\n  \n  // Base query for sent emails\n  let sentQuery = supabase\n    .from('email_events')\n    .select('count')\n    .eq('event_type', 'delivery')\n    .gte('timestamp', startDate.toISOString())\n    .lte('timestamp', endDate.toISOString());\n    \n  // Apply filters if provided\n  if (campaignId) {\n    sentQuery = sentQuery.eq('campaign_id', campaignId);\n  }\n  \n  if (emailType) {\n    sentQuery = sentQuery.eq('email_type', emailType);\n  }\n  \n  // Execute sent emails query\n  const { data: sentData, error: sentError } = await sentQuery;\n  \n  if (sentError) throw sentError;\n  \n  // Similar queries for opens, clicks, bounces, etc.\n  // ...\n  \n  // Get daily stats for time series\n  const { data: dailyStats, error: dailyError } = await supabase\n    .rpc('get_daily_email_stats', {\n      start_date: startDate.toISOString(),\n      end_date: endDate.toISOString(),\n      campaign_id: campaignId || null,\n      email_type: emailType || null\n    });\n    \n  if (dailyError) throw dailyError;\n  \n  // Calculate key metrics\n  const totalSent = sentData[0]?.count || 0;\n  const totalOpens = opensData[0]?.count || 0;\n  const totalClicks = clicksData[0]?.count || 0;\n  const totalBounces = bouncesData[0]?.count || 0;\n  const totalComplaints = complaintsData[0]?.count || 0;\n  \n  const openRate = totalSent > 0 ? (totalOpens / totalSent) * 100 : 0;\n  const clickRate = totalSent > 0 ? (totalClicks / totalSent) * 100 : 0;\n  const clickToOpenRate = totalOpens > 0 ? (totalClicks / totalOpens) * 100 : 0;\n  const bounceRate = totalSent > 0 ? (totalBounces / totalSent) * 100 : 0;\n  const complaintRate = totalSent > 0 ? (totalComplaints / totalSent) * 100 : 0;\n  \n  return {\n    summary: {\n      totalSent,\n      totalOpens,\n      totalClicks,\n      totalBounces,\n      totalComplaints,\n      openRate,\n      clickRate,\n      clickToOpenRate,\n      bounceRate,\n      complaintRate\n    },\n    dailyStats\n  };\n}\n\n// Example SQL function for daily stats (to be created in Supabase)\n/*\nCREATE OR REPLACE FUNCTION get_daily_email_stats(\n  start_date TIMESTAMP WITH TIME ZONE,\n  end_date TIMESTAMP WITH TIME ZONE,\n  campaign_id UUID,\n  email_type TEXT\n) RETURNS TABLE (\n  date DATE,\n  sent BIGINT,\n  opens BIGINT,\n  clicks BIGINT,\n  bounces BIGINT,\n  complaints BIGINT\n) AS $$\nBEGIN\n  RETURN QUERY\n  WITH dates AS (\n    SELECT generate_series(start_date::DATE, end_date::DATE, '1 day'::INTERVAL)::DATE AS date\n  ),\n  sent_counts AS (\n    SELECT\n      DATE(timestamp) AS date,\n      COUNT(*) AS count\n    FROM email_events\n    WHERE\n      event_type = 'delivery'\n      AND timestamp >= start_date\n      AND timestamp <= end_date\n      AND (campaign_id IS NULL OR campaign_id = $3)\n      AND (email_type IS NULL OR email_type = $4)\n    GROUP BY DATE(timestamp)\n  ),\n  open_counts AS (\n    -- Similar query for opens\n  ),\n  click_counts AS (\n    -- Similar query for clicks\n  ),\n  bounce_counts AS (\n    -- Similar query for bounces\n  ),\n  complaint_counts AS (\n    -- Similar query for complaints\n  )\n  SELECT\n    d.date,\n    COALESCE(s.count, 0) AS sent,\n    COALESCE(o.count, 0) AS opens,\n    COALESCE(c.count, 0) AS clicks,\n    COALESCE(b.count, 0) AS bounces,\n    COALESCE(cp.count, 0) AS complaints\n  FROM\n    dates d\n    LEFT JOIN sent_counts s ON d.date = s.date\n    LEFT JOIN open_counts o ON d.date = o.date\n    LEFT JOIN click_counts c ON d.date = c.date\n    LEFT JOIN bounce_counts b ON d.date = b.date\n    LEFT JOIN complaint_counts cp ON d.date = cp.date\n  ORDER BY\n    d.date;\nEND;\n$$ LANGUAGE plpgsql;\n*/\n```",
      "testStrategy": "1. Test data aggregation with various filter combinations\n2. Verify metric calculations are accurate\n3. Test dashboard performance with large datasets\n4. Validate visualization rendering with different data patterns\n5. Test export functionality for different report formats\n6. Verify real-time updates for recent campaigns\n7. Test dashboard responsiveness across different devices\n8. Validate filter interactions and state management",
      "priority": "medium",
      "dependencies": [
        24
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "User Email Preference Management",
      "description": "Implement global opt-in/opt-out preference management for users and ensure compliance with email regulations for Philippines audience.",
      "details": "1. Design user email preference UI\n2. Implement preference storage in the database\n3. Create API endpoints for preference management\n4. Add unsubscribe link processing from emails\n5. Implement preference center for users\n6. Add compliance features for email regulations\n7. Create preference history tracking\n8. Implement preference synchronization with Postmark\n\n```typescript\n// Example email preferences schema\n/*\nCREATE TABLE user_email_preferences (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  email VARCHAR(255) NOT NULL,\n  marketing_opt_in BOOLEAN DEFAULT TRUE,\n  educational_opt_in BOOLEAN DEFAULT TRUE,\n  transactional_opt_in BOOLEAN DEFAULT TRUE,\n  is_valid_email BOOLEAN DEFAULT TRUE,\n  bounce_reason TEXT,\n  opt_out_reason TEXT,\n  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id)\n);\n\n-- Preference history table for audit\nCREATE TABLE user_email_preference_history (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  email VARCHAR(255) NOT NULL,\n  preference_type VARCHAR(50) NOT NULL,\n  old_value BOOLEAN,\n  new_value BOOLEAN,\n  changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  changed_by UUID REFERENCES auth.users(id),\n  source VARCHAR(50) -- 'user', 'admin', 'system', 'unsubscribe_link'\n);\n*/\n\n// Example preference management component\nimport React, { useState, useEffect } from 'react';\nimport { supabase } from '../lib/supabaseClient';\n\nconst EmailPreferences = ({ userId }) => {\n  const [preferences, setPreferences] = useState({\n    marketing_opt_in: true,\n    educational_opt_in: true,\n    transactional_opt_in: true\n  });\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [message, setMessage] = useState('');\n  \n  useEffect(() => {\n    // Load user preferences\n    const fetchPreferences = async () => {\n      setLoading(true);\n      \n      const { data, error } = await supabase\n        .from('user_email_preferences')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n        \n      if (error && error.code !== 'PGRST116') { // PGRST116 is \"not found\"\n        console.error('Error loading preferences:', error);\n        setMessage('Failed to load preferences');\n      } else if (data) {\n        setPreferences({\n          marketing_opt_in: data.marketing_opt_in,\n          educational_opt_in: data.educational_opt_in,\n          transactional_opt_in: data.transactional_opt_in\n        });\n      }\n      \n      setLoading(false);\n    };\n    \n    fetchPreferences();\n  }, [userId]);\n  \n  const handleToggle = (preference) => {\n    setPreferences(prev => ({\n      ...prev,\n      [preference]: !prev[preference]\n    }));\n  };\n  \n  const savePreferences = async () => {\n    setSaving(true);\n    setMessage('');\n    \n    try {\n      // Get user's email\n      const { data: userData, error: userError } = await supabase.auth.getUser();\n      \n      if (userError) throw userError;\n      \n      const email = userData.user.email;\n      \n      // Update preferences\n      const { error } = await supabase\n        .from('user_email_preferences')\n        .upsert({\n          user_id: userId,\n          email,\n          marketing_opt_in: preferences.marketing_opt_in,\n          educational_opt_in: preferences.educational_opt_in,\n          transactional_opt_in: preferences.transactional_opt_in,\n          updated_at: new Date()\n        }, {\n          onConflict: 'user_id'\n        });\n        \n      if (error) throw error;\n      \n      // Record history for each changed preference\n      // This would typically be handled by a database trigger\n      \n      setMessage('Preferences saved successfully');\n    } catch (error) {\n      console.error('Error saving preferences:', error);\n      setMessage('Failed to save preferences');\n    } finally {\n      setSaving(false);\n    }\n  };\n  \n  if (loading) {\n    return <div>Loading preferences...</div>;\n  }\n  \n  return (\n    <div className=\"email-preferences\">\n      <h2>Email Preferences</h2>\n      \n      {message && (\n        <div className={message.includes('Failed') ? 'error-message' : 'success-message'}>\n          {message}\n        </div>\n      )}\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.marketing_opt_in}\n            onChange={() => handleToggle('marketing_opt_in')}\n          />\n          Marketing Emails (Sales, promotions, and special offers)\n        </label>\n      </div>\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.educational_opt_in}\n            onChange={() => handleToggle('educational_opt_in')}\n          />\n          Educational Content (Class reminders, instructional content)\n        </label>\n      </div>\n      \n      <div className=\"preference-option\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={preferences.transactional_opt_in}\n            onChange={() => handleToggle('transactional_opt_in')}\n            disabled={true} // Transactional emails can't be opted out of\n          />\n          Transactional Emails (Account updates, purchase confirmations)\n        </label>\n        <small>These emails are required for your account and cannot be disabled.</small>\n      </div>\n      \n      <div className=\"preference-actions\">\n        <button\n          onClick={savePreferences}\n          disabled={saving}\n        >\n          {saving ? 'Saving...' : 'Save Preferences'}\n        </button>\n      </div>\n      \n      <div className=\"preference-info\">\n        <p>\n          We respect your privacy and are committed to protecting your personal data.\n          For more information, please see our <a href=\"/privacy-policy\">Privacy Policy</a>.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default EmailPreferences;\n```",
      "testStrategy": "1. Test preference saving and loading functionality\n2. Verify unsubscribe link processing\n3. Test preference center UI across different devices\n4. Validate compliance with email regulations\n5. Test preference history tracking\n6. Verify preference synchronization with Postmark\n7. Test preference changes impact on email sending\n8. Validate security of preference management endpoints",
      "priority": "high",
      "dependencies": [
        19,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "Authentication Email Templates",
      "description": "Create and implement custom email templates for authentication flows including registration, welcome, password reset, and magic links.",
      "status": "cancelled",
      "dependencies": [
        18,
        19
      ],
      "priority": "high",
      "details": "**NOTE: This task is now deprecated/completed. The creation and implementation of custom authentication email templates are being handled as part of the Unlayer email editor integration (Task 32).**\n\nRefer to `ProjectDocs/Build_Notes/unlayer-email-editor-integration_phase-1_implementation.md` which lists these templates as part of completed work with Unlayer.\n\n~~1. Design and implement the following authentication email templates:~~\n   ~~- Email verification~~\n   ~~- Welcome email~~\n   ~~- Password reset~~\n   ~~- Magic link authentication~~\n~~2. Ensure templates follow Graceful Homeschooling brand guidelines~~\n~~3. Implement responsive design using MJML~~\n~~4. Add appropriate security messaging~~\n~~5. Ensure clear call-to-action buttons~~\n~~6. Implement template variables for personalization~~\n\nThe original MJML template examples and implementation code have been superseded by the Unlayer implementation in Task 32.",
      "testStrategy": "**NOTE: Testing for authentication email templates is now being handled as part of Task 32 (Unlayer email editor integration).**\n\nThe following test strategy has been transferred to Task 32:\n1. Test template rendering with various user data\n2. Verify responsive design across different email clients\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate security messaging is clear and accurate",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Transactional Email Templates",
      "description": "Create and implement transactional email templates for order confirmations, class enrollments, and other system notifications using Unlayer (Task 32).",
      "status": "pending",
      "dependencies": [
        23,
        32
      ],
      "priority": "high",
      "details": "1. Design and implement the following transactional email templates using Unlayer:\n   - Order confirmation\n   - Class enrollment confirmation\n   - Payment receipt\n   - Account updates\n   - System notifications\n2. Ensure templates follow Graceful Homeschooling brand guidelines\n3. Implement responsive design using Unlayer's responsive template features\n4. Add appropriate transaction details and formatting\n5. Ensure clear call-to-action buttons where applicable\n6. Implement template variables for personalization and transaction details\n7. Refer to Unlayer build notes in subtask 32.1 for creating these template types (e.g., 'Course enrollment templates')\n\nNote: Previously planned MJML implementation has been replaced with Unlayer as per Task 32.\n\n```typescript\n// Example function to register transactional templates with Postmark using Unlayer HTML\nasync function registerTransactionalTemplates() {\n  const postmarkClient = new PostmarkClient(process.env.POSTMARK_API_TOKEN);\n  \n  // Class enrollment template - now using Unlayer HTML export\n  const enrollmentHtml = await getUnlayerTemplateHtml('class-enrollment');\n  \n  await postmarkClient.createTemplate({\n    Name: 'Class Enrollment Confirmation',\n    Subject: 'Your Enrollment in {{className}} is Confirmed',\n    HtmlBody: enrollmentHtml,\n    TextBody: 'Thank you for enrolling in {{className}}. Your class is scheduled for {{classSchedule}} starting on {{startDate}}.',\n    TemplateType: 'Standard'\n  });\n  \n  // Similar code for other transactional templates...\n}\n\n// Function to get HTML from Unlayer template\nasync function getUnlayerTemplateHtml(templateName) {\n  // Implementation will depend on how Unlayer templates are stored/exported\n  // This could involve API calls to Unlayer or reading from exported files\n  return unlayerExportedHtml;\n}\n```",
      "testStrategy": "1. Test template rendering with various transaction data\n2. Verify responsive design across different email clients using Unlayer's responsive templates\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate transaction details are clearly presented\n9. Verify integration between Unlayer exports and email sending system\n10. Test compatibility with Postmark's template system",
      "subtasks": [
        {
          "id": "28.1",
          "title": "Review Unlayer build notes from subtask 32.1",
          "description": "Review the Unlayer build notes and template structure from subtask 32.1 to understand how to create the required transactional email templates.",
          "status": "pending"
        },
        {
          "id": "28.2",
          "title": "Create order confirmation template in Unlayer",
          "description": "Design and implement the order confirmation email template using Unlayer, ensuring it includes all necessary transaction details and follows brand guidelines.",
          "status": "pending"
        },
        {
          "id": "28.3",
          "title": "Create class enrollment confirmation template in Unlayer",
          "description": "Design and implement the class enrollment confirmation email template using Unlayer, including class details, instructor information, and calendar integration options.",
          "status": "pending"
        },
        {
          "id": "28.4",
          "title": "Create payment receipt template in Unlayer",
          "description": "Design and implement the payment receipt email template using Unlayer, ensuring it includes all necessary payment details and follows financial reporting requirements.",
          "status": "pending"
        },
        {
          "id": "28.5",
          "title": "Create account updates template in Unlayer",
          "description": "Design and implement the account updates email template using Unlayer for notifying users about changes to their account information.",
          "status": "pending"
        },
        {
          "id": "28.6",
          "title": "Create system notifications template in Unlayer",
          "description": "Design and implement the system notifications email template using Unlayer for general platform announcements and alerts.",
          "status": "pending"
        },
        {
          "id": "28.7",
          "title": "Implement template variable system for Unlayer templates",
          "description": "Set up the template variable system to work with Unlayer exports, ensuring proper substitution of personalization and transaction details.",
          "status": "pending"
        },
        {
          "id": "28.8",
          "title": "Integrate Unlayer templates with Postmark",
          "description": "Develop the integration between Unlayer-exported templates and the Postmark email delivery system.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 29,
      "title": "Marketing Email Templates",
      "description": "Create and implement marketing email templates (campaigns, promotions, educational content) using Unlayer (Task 32), following brand guidelines and respecting user preferences (Task 26).",
      "status": "pending",
      "dependencies": [
        26,
        32
      ],
      "priority": "medium",
      "details": "1. Design and implement the following marketing email templates using Unlayer:\n   - Newsletter template\n   - Promotion/sale announcement template\n   - Free class invitation template\n   - Educational content template\n   - Product announcement template\n2. Ensure templates follow Graceful Homeschooling brand guidelines\n3. Implement responsive design using Unlayer's responsive editor\n4. Add appropriate marketing content sections and layouts\n5. Ensure clear call-to-action buttons\n6. Implement template variables for personalization\n7. Add required unsubscribe links and compliance elements\n8. Reference Unlayer build notes from subtask 32.1 for template types ('Newsletter', 'Announcement', 'Marketing campaign')\n9. Ensure templates respect user preferences as defined in Task 26\n\nNote: The previous MJML implementation has been replaced with Unlayer as per Task 32. The example code below should be updated accordingly when implementing.\n\n```typescript\n// Example function to register marketing templates with Postmark using Unlayer HTML\nasync function registerMarketingTemplates() {\n  const postmarkClient = new PostmarkClient(process.env.POSTMARK_API_TOKEN);\n  \n  // Promotion template\n  const promotionHtml = await getUnlayerTemplateHtml('promotion-announcement');\n  \n  await postmarkClient.createTemplate({\n    Name: 'Promotion Announcement',\n    Subject: '{{promotionSubject}}',\n    HtmlBody: promotionHtml,\n    TextBody: 'Special offer for Graceful Homeschooling members! {{promotionOffer}} Use code: {{promotionCode}}. Offer valid until: {{expirationDate}}. {{promotionUrl}}',\n    TemplateType: 'Standard'\n  });\n  \n  // Similar code for other marketing templates...\n}\n\n// Function to retrieve HTML from Unlayer templates\nasync function getUnlayerTemplateHtml(templateName) {\n  // Implementation will depend on how Unlayer templates are stored/retrieved\n  // This could involve API calls to Unlayer or retrieving from database\n}\n```",
      "testStrategy": "1. Test template rendering with various marketing content in Unlayer\n2. Verify responsive design across different email clients\n3. Test all links and buttons in templates\n4. Validate template variables are correctly substituted\n5. Test accessibility of email templates\n6. Verify branding consistency across all templates\n7. Test template loading times and size\n8. Validate unsubscribe links and compliance elements\n9. Verify templates respect user preference settings from Task 26\n10. Test export and integration of Unlayer templates with email sending service",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "Email Campaign Scheduling and Automation",
      "description": "Implement scheduling functionality for email campaigns and automation for recurring emails such as class reminders.",
      "details": "1. Design and implement campaign scheduling system\n2. Create automation rules for recurring emails\n3. Implement timezone handling for scheduled sends\n4. Add batch processing for large campaigns\n5. Create retry mechanism for failed sends\n6. Implement campaign status tracking and notifications\n7. Add campaign pause/resume functionality\n8. Create campaign analytics tracking\n\n```typescript\n// Example campaign scheduler implementation\nimport { CronJob } from 'cron';\nimport { supabase } from '../lib/supabaseClient';\nimport { EmailService } from '../lib/emailService';\nimport { logger } from '../lib/logger';\n\nconst emailService = new EmailService(process.env.POSTMARK_API_TOKEN);\n\n// Initialize scheduler\nexport function initCampaignScheduler() {\n  // Check for campaigns to send every minute\n  const job = new CronJob('* * * * *', async function() {\n    await processPendingCampaigns();\n    await processRecurringCampaigns();\n  });\n  \n  job.start();\n  logger.info('Campaign scheduler initialized');\n}\n\n// Process one-time campaigns that are scheduled to send\nasync function processPendingCampaigns() {\n  const now = new Date();\n  \n  // Find campaigns that are scheduled to send now\n  const { data: campaigns, error } = await supabase\n    .from('email_campaigns')\n    .select('*')\n    .eq('status', 'scheduled')\n    .eq('is_recurring', false)\n    .lte('scheduled_for', now.toISOString())\n    .order('scheduled_for', { ascending: true })\n    .limit(5); // Process in small batches\n    \n  if (error) {\n    logger.error('Error fetching pending campaigns', { error });\n    return;\n  }\n  \n  if (!campaigns || campaigns.length === 0) {\n    return; // No campaigns to process\n  }\n  \n  for (const campaign of campaigns) {\n    await processCampaign(campaign);\n  }\n}\n\n// Process recurring campaigns\nasync function processRecurringCampaigns() {\n  const now = new Date();\n  \n  // Find recurring campaigns that need to be processed\n  const { data: campaigns, error } = await supabase\n    .from('email_campaigns')\n    .select('*')\n    .eq('status', 'active')\n    .eq('is_recurring', true)\n    .lte('next_send_date', now.toISOString())\n    .order('next_send_date', { ascending: true })\n    .limit(5); // Process in small batches\n    \n  if (error) {\n    logger.error('Error fetching recurring campaigns', { error });\n    return;\n  }\n  \n  if (!campaigns || campaigns.length === 0) {\n    return; // No campaigns to process\n  }\n  \n  for (const campaign of campaigns) {\n    await processCampaign(campaign);\n    \n    // Calculate next send date based on recurrence pattern\n    const nextSendDate = calculateNextSendDate(campaign.recurrence_pattern, now);\n    \n    // Update campaign with next send date\n    await supabase\n      .from('email_campaigns')\n      .update({\n        next_send_date: nextSendDate.toISOString(),\n        last_sent_at: now.toISOString()\n      })\n      .eq('id', campaign.id);\n  }\n}\n\n// Process a single campaign\nasync function processCampaign(campaign) {\n  try {\n    // Update campaign status to processing\n    await supabase\n      .from('email_campaigns')\n      .update({ status: 'processing', processing_started_at: new Date().toISOString() })\n      .eq('id', campaign.id);\n    \n    // Get recipients based on segment\n    const recipients = await getRecipientsForCampaign(campaign);\n    \n    if (!recipients || recipients.length === 0) {\n      logger.warn('No recipients found for campaign', { campaignId: campaign.id });\n      await updateCampaignStatus(campaign.id, 'completed', 'No recipients found');\n      return;\n    }\n    \n    // Get template data\n    const { data: template, error: templateError } = await supabase\n      .from('email_templates')\n      .select('*')\n      .eq('id', campaign.template_id)\n      .single();\n      \n    if (templateError) {\n      logger.error('Error fetching template for campaign', { campaignId: campaign.id, error: templateError });\n      await updateCampaignStatus(campaign.id, 'error', 'Template not found');\n      return;\n    }\n    \n    // Send campaign\n    const result = await emailService.sendMarketingEmail({\n      recipients: recipients.map(r => ({\n        email: r.email,\n        data: {\n          firstName: r.first_name,\n          lastName: r.last_name,\n          // Add other personalization variables\n          unsubscribeUrl: `${process.env.NEXT_PUBLIC_APP_URL}/unsubscribe?email=${encodeURIComponent(r.email)}&token=${generateUnsubscribeToken(r.email)}`,\n          preferencesUrl: `${process.env.NEXT_PUBLIC_APP_URL}/preferences?email=${encodeURIComponent(r.email)}&token=${generatePreferencesToken(r.email)}`\n        }\n      })),\n      subject: campaign.subject,\n      templateId: template.postmark_template_id,\n      from: `${campaign.from_name} <${campaign.from_email}>`,\n      messageStream: 'broadcast'\n    });\n    \n    if (!result.success) {\n      throw new Error('Failed to send campaign: ' + JSON.stringify(result.error));\n    }\n    \n    // Update campaign status to completed\n    await updateCampaignStatus(campaign.id, 'completed', `Sent to ${recipients.length} recipients`);\n    \n    // Record campaign metrics\n    await supabase\n      .from('campaign_metrics')\n      .insert({\n        campaign_id: campaign.id,\n        recipient_count: recipients.length,\n        sent_at: new Date().toISOString()\n      });\n      \n  } catch (error) {\n    logger.error('Error processing campaign', { campaignId: campaign.id, error });\n    await updateCampaignStatus(campaign.id, 'error', error.message);\n  }\n}\n\n// Helper function to update campaign status\nasync function updateCampaignStatus(campaignId, status, statusMessage = '') {\n  await supabase\n    .from('email_campaigns')\n    .update({\n      status,\n      status_message: statusMessage,\n      updated_at: new Date().toISOString(),\n      processing_completed_at: status !== 'processing' ? new Date().toISOString() : null\n    })\n    .eq('id', campaignId);\n}\n\n// Helper function to get recipients for a campaign\nasync function getRecipientsForCampaign(campaign) {\n  // Get segment definition\n  const { data: segment, error: segmentError } = await supabase\n    .from('user_segments')\n    .select('*')\n    .eq('id', campaign.segment_id)\n    .single();\n    \n  if (segmentError) {\n    logger.error('Error fetching segment for campaign', { campaignId: campaign.id, error: segmentError });\n    throw new Error('Segment not found');\n  }\n  \n  // Evaluate segment to get recipient IDs\n  const recipientIds = await evaluateSegment(segment.id);\n  \n  // Get recipient details\n  const { data: recipients, error: recipientsError } = await supabase\n    .from('profiles')\n    .select('email, first_name, last_name')\n    .in('id', recipientIds)\n    .eq('email_verified', true); // Only send to verified emails\n    \n  if (recipientsError) {\n    logger.error('Error fetching recipients for campaign', { campaignId: campaign.id, error: recipientsError });\n    throw new Error('Failed to fetch recipients');\n  }\n  \n  return recipients;\n}\n\n// Helper function to calculate next send date for recurring campaigns\nfunction calculateNextSendDate(recurrencePattern, fromDate) {\n  const pattern = JSON.parse(recurrencePattern);\n  const nextDate = new Date(fromDate);\n  \n  switch (pattern.frequency) {\n    case 'daily':\n      nextDate.setDate(nextDate.getDate() + pattern.interval);\n      break;\n    case 'weekly':\n      nextDate.setDate(nextDate.getDate() + (pattern.interval * 7));\n      break;\n    case 'monthly':\n      nextDate.setMonth(nextDate.getMonth() + pattern.interval);\n      break;\n    default:\n      throw new Error(`Unknown frequency: ${pattern.frequency}`);\n  }\n  \n  return nextDate;\n}\n\n// Helper functions for security tokens\nfunction generateUnsubscribeToken(email) {\n  // Implementation would use a secure method to generate a token\n  // that can be validated when the unsubscribe link is clicked\n  return 'token'; // Placeholder\n}\n\nfunction generatePreferencesToken(email) {\n  // Similar to unsubscribe token\n  return 'token'; // Placeholder\n}\n```",
      "testStrategy": "1. Test campaign scheduling with various time configurations\n2. Verify timezone handling for different user locations\n3. Test recurring campaign patterns (daily, weekly, monthly)\n4. Validate batch processing for large recipient lists\n5. Test retry mechanism for failed sends\n6. Verify campaign status updates throughout the process\n7. Test pause/resume functionality\n8. Validate analytics tracking for scheduled campaigns",
      "priority": "medium",
      "dependencies": [
        22,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "Task #31: Implement Direct HTML Email Template System",
      "description": "Develop a simplified email template system that uses TipTap to generate clean, responsive HTML directly without MJML conversion, while maintaining Graceful Homeschooling brand guidelines and providing an admin interface for template management.",
      "status": "in-progress",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves replacing our current MJML-based email template system with a more streamlined approach using direct HTML generation. We've made significant progress with the following accomplishments:\n\n1. ✅ Created new responsive HTML email templates based on Graceful Homeschooling's design guidelines\n2. ✅ Removed MJML dependency completely\n3. ✅ Updated TipTap extensions to generate email-friendly HTML directly\n4. ✅ Created a focused email HTML processor to ensure email client compatibility\n5. ✅ Updated the template manager to handle HTML templates directly\n6. ✅ Fixed the test email functionality to work with the new approach\n7. ✅ Cleaned up old MJML files and converters\n8. ✅ Enhanced the library of reusable HTML components with 5 new components (Email Card, Email Image, Email Spacing, Email Header, and Email Footer)\n9. ✅ Updated the HTML processor to handle all new components\n10. ✅ Created an index file for easy imports of components\n11. ✅ Added a sample marketing newsletter template demonstrating all components\n\nRemaining work includes:\n\n1. Complete the admin interface for template management:\n   - Finalize template categorization (transactional, marketing, etc.)\n   - Implement version history and rollback capabilities\n   - Enhance template variables system for personalization\n\n2. Further Postmark API integration improvements:\n   - Refine error handling and delivery tracking\n   - Enhance template testing functionality for different email clients\n\n3. Performance optimizations:\n   - Further optimize HTML output for email client compatibility\n   - Implement caching for frequently used templates\n   - Fine-tune inline CSS while maintaining compatibility",
      "testStrategy": "Testing for this task will involve multiple stages to ensure the new email template system functions correctly. We've already validated the direct HTML approach is working properly, and we'll continue with:\n\n1. Unit Testing:\n   - Complete testing of TipTap HTML generation for proper email-compatible output\n   - Verify all template components render correctly and responsively\n   - Test admin interface CRUD operations for templates\n   - Validate Postmark API integration functions properly\n\n2. Integration Testing:\n   - Verify end-to-end flow from template creation to email delivery\n   - Test template variable substitution works correctly\n   - Ensure proper error handling throughout the system\n\n3. Email Client Compatibility Testing:\n   - Continue testing templates in major email clients (Gmail, Outlook, Apple Mail, etc.)\n   - Verify responsive behavior on mobile email clients\n   - Use Email on Acid or Litmus to test across a wide range of clients\n   - Test the new components (Email Card, Email Image, Email Spacing, Email Header, and Email Footer) across all major clients\n\n4. User Acceptance Testing:\n   - Have marketing team review and approve template designs\n   - Conduct usability testing of the admin interface with actual users\n   - Verify that templates meet brand guidelines\n   - Get feedback on the sample marketing newsletter template\n\n5. Performance Testing:\n   - Measure template rendering time compared to previous MJML approach\n   - Test system under load with multiple concurrent template operations\n   - Verify caching mechanisms work as expected\n\n6. Final Validation:\n   - Ensure all templates render correctly across major email clients\n   - Verify the admin interface allows non-technical users to manage templates effectively\n   - Confirm the system successfully delivers emails through Postmark\n   - Validate all templates follow Graceful Homeschooling brand guidelines\n   - Document performance improvements over the previous MJML approach",
      "subtasks": [
        {
          "id": "31.1",
          "title": "Create responsive HTML email templates based on brand guidelines",
          "status": "done"
        },
        {
          "id": "31.2",
          "title": "Remove MJML dependency",
          "status": "done"
        },
        {
          "id": "31.3",
          "title": "Update TipTap extensions for email-friendly HTML",
          "status": "done"
        },
        {
          "id": "31.4",
          "title": "Create email HTML processor for client compatibility",
          "status": "done"
        },
        {
          "id": "31.5",
          "title": "Update template manager for direct HTML handling",
          "status": "done"
        },
        {
          "id": "31.6",
          "title": "Fix test email functionality",
          "status": "done"
        },
        {
          "id": "31.7",
          "title": "Clean up old MJML files and converters",
          "status": "done"
        },
        {
          "id": "31.8",
          "title": "Enhance reusable HTML component library",
          "status": "done"
        },
        {
          "id": "31.9",
          "title": "Complete admin interface for template management",
          "status": "to-do"
        },
        {
          "id": "31.10",
          "title": "Refine Postmark API integration",
          "status": "to-do"
        },
        {
          "id": "31.11",
          "title": "Implement performance optimizations",
          "status": "to-do"
        },
        {
          "id": "31.12",
          "title": "Conduct comprehensive email client testing",
          "status": "to-do"
        }
      ]
    },
    {
      "id": 32,
      "title": "Integrate Unlayer Email Editor",
      "description": "Replace the current TipTap-based email editor with Unlayer's react-email-editor to provide a professional, drag-and-drop email template editing experience for non-technical admin users.",
      "details": "Context: Our current email template editing solution has several limitations (Not truly WYSIWYG, limited components, requires HTML knowledge, no proper preview, error-prone saving/previewing). Unlayer provides a professional solution with drag-and-drop capabilities, responsive templates, and real-time previews.\nImplementation Details:\n1. Installation and Setup: Install react-email-editor, create EmailEditor wrapper, configure branding.\n2. API Enhancement: Update API to store HTML & design JSON, add design field to schema, improve version management.\n3. User Interface: Replace TipTap with Unlayer, update management screens, create template gallery.\n4. Migration: Convert existing HTML templates (Note: Build notes indicate creating *new* templates instead of migrating existing ones - this needs clarification).\nTechnical Notes: Package: react-email-editor, iframe-based (check CSP), store design JSON with HTML.\nResources: Unlayer Docs, react-email-editor GitHub, Unlayer templates examples.",
      "testStrategy": "Verify Unlayer editor integrated; templates can be created/edited/saved via drag-and-drop; HTML & design JSON stored; variable substitution (merge tags) works; templates can be previewed across devices/clients; version history and rollback functionality is preserved. (Migration of existing templates needs clarification based on conflicting information: task file says migrate, build note says create new).",
      "status": "in-progress",
      "dependencies": [
        31
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Additional Standard Email Template Types with Unlayer",
          "description": "Design and implement a set of standard, well-designed email templates using the Unlayer editor for common use cases.",
          "details": "Specific template types to create:\n- Newsletter templates (e.g., monthly updates, featured content)\n- Announcement templates (e.g., new features, important notices)\n- Marketing campaign templates (e.g., promotions, special offers)\n- Course enrollment templates (e.g., confirmation, pre-course information, reminders)\nEnsure all templates are responsive, align with Graceful Homeschooling branding, and utilize Unlayer's features effectively.\n<info added on 2025-05-08T06:39:11.250Z>\nSpecific template types to create:\n- Newsletter templates (e.g., monthly updates, featured content)\n- Announcement templates (e.g., new features, important notices)\n- Marketing campaign templates (e.g., promotions, special offers)\n- Course enrollment templates (e.g., confirmation, pre-course information, reminders)\nEnsure all templates are responsive, align with Graceful Homeschooling branding, and utilize Unlayer's features effectively.\n\nThis subtask has been cancelled in its current location. The work has been moved and is now being tracked as Subtask 34.2 under 'Phase 1: Solidify Core Email Infrastructure (Postmark & Unlayer)' (Task 34). Please refer to Task 34.2 for all future updates and implementation details regarding the creation of standard email templates.\n</info added on 2025-05-08T06:39:11.250Z>",
          "status": "cancelled",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 2,
          "title": "Implement Enhanced Template Management Features (Delete, Rename, Duplicate)",
          "description": "Enhance the Unlayer template management interface with core CRUD operations.",
          "details": "Implement the following functionalities for email templates managed via Unlayer:\n- Ability to delete templates (with confirmation).\n- Ability to rename existing templates.\n- Template duplication functionality to allow admins to quickly create new templates based on existing ones.\nEnsure these operations correctly handle both the HTML and design JSON stored for each template, and interact correctly with any version history.\n<info added on 2025-05-08T06:39:27.692Z>\nImplement the following functionalities for email templates managed via Unlayer:\n- Ability to delete templates (with confirmation).\n- Ability to rename existing templates.\n- Template duplication functionality to allow admins to quickly create new templates based on existing ones.\nEnsure these operations correctly handle both the HTML and design JSON stored for each template, and interact correctly with any version history.\n\nThis subtask has been moved and is now tracked as Subtask 34.3 under 'Phase 1: Solidify Core Email Infrastructure (Postmark & Unlayer)' (Task 34). The work will continue there with the same requirements and specifications. This subtask is now cancelled in the current location.\n</info added on 2025-05-08T06:39:27.692Z>",
          "status": "cancelled",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 3,
          "title": "Conduct Comprehensive Email Client Testing for Unlayer Templates",
          "description": "Thoroughly test all email templates created with Unlayer across a wide range of email clients and devices.",
          "details": "Testing scope includes:\n- Major desktop clients (Outlook, Apple Mail, Thunderbird).\n- Major webmail clients (Gmail, Outlook.com, Yahoo Mail).\n- Major mobile clients (iOS Mail, Android Gmail, Outlook Mobile).\n- Verify responsive design and correct rendering of all Unlayer components and custom branding.\n- Use tools like Email on Acid or Litmus for broader compatibility checks if available.\n- Document any rendering issues and address them by adjusting templates or Unlayer configurations.\n<info added on 2025-05-08T06:39:51.209Z>\nTesting scope includes:\n- Major desktop clients (Outlook, Apple Mail, Thunderbird).\n- Major webmail clients (Gmail, Outlook.com, Yahoo Mail).\n- Major mobile clients (iOS Mail, Android Gmail, Outlook Mobile).\n- Verify responsive design and correct rendering of all Unlayer components and custom branding.\n- Use tools like Email on Acid or Litmus for broader compatibility checks if available.\n- Document any rendering issues and address them by adjusting templates or Unlayer configurations.\n\nThis subtask has been relocated and is now being tracked as Subtask 34.4 under 'Phase 1: Solidify Core Email Infrastructure (Postmark & Unlayer)' (Task 34). All testing activities and documentation should be continued under the new subtask. This subtask is now cancelled in its current location.\n</info added on 2025-05-08T06:39:51.209Z>",
          "status": "cancelled",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 4,
          "title": "Train Admin Users on Unlayer Email Editor",
          "description": "Provide training to administrative staff on how to use the new Unlayer email editor.",
          "details": "Training should cover:\n- Overview of the Unlayer interface and its features.\n- Creating new templates from scratch or using pre-designed starting points.\n- Using drag-and-drop components.\n- Customizing template styles and branding.\n- Adding and managing personalization merge tags.\n- Previewing templates on different devices.\n- Saving, loading, and managing template versions.\n- Best practices for creating effective and responsive emails.\n- Develop training materials (e.g., guides, video tutorials) if necessary.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 5,
          "title": "Document New Unlayer Template Creation Process",
          "description": "Create comprehensive documentation for the content team and administrators on the new email template creation and management process using Unlayer.",
          "details": "Documentation should include:\n- Step-by-step guide for creating, editing, and managing email templates with Unlayer.\n- Explanation of available Unlayer components and features.\n- Guidelines for maintaining brand consistency.\n- Instructions for using personalization merge tags.\n- Troubleshooting common issues.\n- Overview of the template approval and publishing workflow (if any).\n- Links to Unlayer's own documentation for advanced features.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        }
      ]
    },
    {
      "id": 33,
      "title": "Deprecate TipTap-based Admin Interface for Email Templates",
      "description": "The admin interface for email template management, originally planned as part of Task 31 (Implement Direct HTML Email Template System) using TipTap, is now deprecated. This functionality is superseded by the Unlayer email editor integration (Task 32), which provides a comprehensive template management interface.",
      "details": "This task records the deprecation of the planned TipTap-based admin interface for managing email templates (originally subtask 31.9 under Task #31). The Unlayer email editor (Task #32) now provides the required visual editor and template management capabilities. No further work is needed on the TipTap-based admin interface for email templates.",
      "testStrategy": "N/A - Informational task. Verify Task 32 (Unlayer) covers all admin template management needs.",
      "status": "done",
      "dependencies": [
        31,
        32
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "Phase 1: Solidify Core Email Infrastructure (Postmark & Unlayer)",
      "description": "This phase focuses on completing the foundational setup for Postmark and the Unlayer editor, ensuring core functionalities like bounce handling, basic template creation, and essential Unlayer features are robust and ready.",
      "details": "Key objectives for this phase include: Finalizing Postmark webhook integration (Task 16.6), completing core Unlayer template creation (Subtask 32.1), implementing essential Unlayer management features (Subtask 32.2), and conducting initial Unlayer template testing (Subtask 32.3).",
      "testStrategy": "Verify completion of all sub-tasks. Core email sending, template editing, and bounce handling must be functional.",
      "status": "done",
      "dependencies": [],
      "priority": "critical",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Bounce Handling and Webhook Integration (from 16.6)",
          "description": "Configure bounce handling and set up webhook endpoints to process Postmark email events. (Originally Subtask 16.6)",
          "details": "Original Subtask 16.6. \n1. Create webhook endpoints in the Next.js application (e.g., `/api/webhooks/postmark`) to receive Postmark events.\n2. Configure Postmark to send bounce, delivery, open, click, and spam complaint events to these endpoints for all relevant message streams.\n3. Implement robust server-side logic to securely process these webhook events. This includes:\n    - Verifying webhook authenticity.\n    - Parsing event data.\n    - Updating user records in Supabase (e.g., mark email as bounced, update engagement flags).\n    - Logging webhook events and any processing errors.\n4. Set up monitoring and alerting for high bounce rates, delivery issues, or webhook failures.\n5. Thoroughly test the complete email sending and event handling flow, including simulating various event types.\n<info added on 2025-05-08T07:06:56.820Z>\nOriginal Subtask 16.6. \\n1. Create webhook endpoints in the Next.js application (e.g., `/api/webhooks/postmark`) to receive Postmark events.\\n2. Configure Postmark to send bounce, delivery, open, click, and spam complaint events to these endpoints for all relevant message streams.\\n3. Implement robust server-side logic to securely process these webhook events. This includes:\\n    - Verifying webhook authenticity.\\n    - Parsing event data.\\n    - Updating user records in Supabase (e.g., mark email as bounced, update engagement flags).\\n    - Logging webhook events and any processing errors.\\n4. Set up monitoring and alerting for high bounce rates, delivery issues, or webhook failures.\\n5. Thoroughly test the complete email sending and event handling flow, including simulating various event types.\\n\\nImplementation Progress:\\n- Added `email_bounced` boolean column (default false) to `unified_profiles` table via Supabase migration to track bounced email addresses\\n- Created initial API route handler at `app/api/webhooks/postmark/route.ts` to receive webhook events from Postmark\\n- Implemented basic signature verification as a placeholder (needs refinement based on final Postmark security method selection)\\n- Implemented event handling logic for `Bounce` events that sets `email_bounced = true` in the `unified_profiles` table\\n- Implemented event handling logic for `SpamComplaint` events that updates `user_email_preferences` and sets `email_bounced = true`\\n- Added placeholder logic for tracking `Open` and `Click` events for future engagement analytics\\n\\nRemaining Tasks:\\n- Configure environment variables for Postmark webhook authentication\\n- Refine signature verification implementation based on chosen Postmark security method\\n- Evaluate and potentially implement comprehensive Open/Click tracking for email engagement metrics\\n- Deploy webhook endpoint to production environment\\n- Test webhook integration with Postmark using their testing tools to simulate various event types\n</info added on 2025-05-08T07:06:56.820Z>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 34
        },
        {
          "id": 2,
          "title": "Create Standard Email Template Types with Unlayer (from 32.1)",
          "description": "Design and implement standard email templates (Newsletter, Announcement, Marketing, Course enrollment) using Unlayer. (Originally Subtask 32.1)",
          "details": "Original Subtask 32.1.\nSpecific template types to create:\n- Newsletter templates (e.g., monthly updates, featured content)\n- Announcement templates (e.g., new features, important notices)\n- Marketing campaign templates (e.g., promotions, special offers)\n- Course enrollment templates (e.g., confirmation, pre-course information, reminders)\nEnsure all templates are responsive, align with Graceful Homeschooling branding, and utilize Unlayer's features effectively.\n<info added on 2025-05-08T07:22:32.757Z>\nOriginal Subtask 32.1.\nSpecific template types to create:\n- Newsletter templates (e.g., monthly updates, featured content)\n- Announcement templates (e.g., new features, important notices)\n- Marketing campaign templates (e.g., promotions, special offers)\n- Course enrollment templates (e.g., confirmation, pre-course information, reminders)\nEnsure all templates are responsive, align with Graceful Homeschooling branding, and utilize Unlayer's features effectively.\n\nDatabase setup has been completed with placeholder records created in the `public.email_templates` table for the following standard template types:\n- Newsletter\n- Announcement\n- Marketing Campaign\n\nThe existing 'Course Enrollment' template has been reused rather than creating a new placeholder. These template records are now ready in the database, but require visual design work and content population. This design work should be done using the integrated Unlayer editor in the admin interface.\n\nThe technical infrastructure is complete, but the templates need creative design work to align with branding guidelines before they can be used in production.\n</info added on 2025-05-08T07:22:32.757Z>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 34
        },
        {
          "id": 3,
          "title": "Implement Unlayer Template Management Features (from 32.2)",
          "description": "Enhance Unlayer template management with Delete, Rename, Duplicate features. (Originally Subtask 32.2)",
          "details": "Original Subtask 32.2.\nImplement the following functionalities for email templates managed via Unlayer:\n- Ability to delete templates (with confirmation).\n- Ability to rename existing templates.\n- Template duplication functionality to allow admins to quickly create new templates based on existing ones.\nEnsure these operations correctly handle both the HTML and design JSON stored for each template, and interact correctly with any version history.\n<info added on 2025-05-08T07:24:28.704Z>\nOriginal Subtask 32.2.\nImplement the following functionalities for email templates managed via Unlayer:\n- Ability to delete templates (with confirmation).\n- Ability to rename existing templates.\n- Template duplication functionality to allow admins to quickly create new templates based on existing ones.\nEnsure these operations correctly handle both the HTML and design JSON stored for each template, and interact correctly with any version history.\n\nImplementation details:\n- Created API route handlers:\n  - `app/api/admin/email-templates/[id]/route.ts` (DELETE for deletion, PUT for rename)\n  - `app/api/admin/email-templates/[id]/duplicate/route.ts` (POST for duplication)\n- Implemented admin access checks in API routes to ensure only authorized users can manage templates.\n- Created a basic admin page `app/admin/email-templates/page.tsx` to fetch and display templates.\n- Developed a client component `components/admin/email-templates/EmailTemplateList.tsx` with:\n  - Table display of templates with relevant metadata.\n  - Action buttons for Delete, Rename, and Duplicate operations.\n  - Client-side logic to call the respective API endpoints.\n  - Rename functionality implemented using a Dialog modal for better UX.\n  - Added loading states and toast notifications (using sonner) for improved user feedback.\n- All operations properly handle both HTML content and design JSON to maintain template integrity.\n- Ensured proper error handling and validation throughout the implementation.\n</info added on 2025-05-08T07:24:28.704Z>\n<info added on 2025-05-08T08:24:57.712Z>\nThe Rename, Delete, and Duplicate functionalities have been fully integrated into the main `app/admin/email-templates/email-templates-manager.tsx` component. This consolidation creates a single, comprehensive interface for template management, improving the user experience and maintainability of the codebase.\n\nKey implementation details:\n- Refactored the previously separate UI components into the main email-templates-manager.tsx component\n- Implemented DropdownMenu for template actions (rename, delete, duplicate) to provide a clean, intuitive interface\n- Created modal Dialogs for rename and delete operations that require confirmation\n- Ensured all UI elements maintain consistent styling and behavior with the rest of the admin interface\n- Updated API calls to maintain the same functionality while working within the consolidated component\n- Added appropriate loading states and success/error notifications for all operations\n- Verified that the consolidated interface properly handles all template operations including HTML content and design JSON management\n- Improved code organization by centralizing template management logic in a single component\n</info added on 2025-05-08T08:24:57.712Z>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 34
        },
        {
          "id": 4,
          "title": "Conduct Email Client Testing for Unlayer Templates (from 32.3)",
          "description": "Test Unlayer templates across email clients and devices. (Originally Subtask 32.3)",
          "details": "Original Subtask 32.3.\nTesting scope includes:\n- Major desktop clients (Outlook, Apple Mail, Thunderbird).\n- Major webmail clients (Gmail, Outlook.com, Yahoo Mail).\n- Major mobile clients (iOS Mail, Android Gmail, Outlook Mobile).\n- Verify responsive design and correct rendering of all Unlayer components and custom branding.\n- Use tools like Email on Acid or Litmus for broader compatibility checks if available.\n- Document any rendering issues and address them by adjusting templates or Unlayer configurations.\n<info added on 2025-05-08T07:24:58.491Z>\nOriginal Subtask 32.3.\nTesting scope includes:\n- Major desktop clients (Outlook, Apple Mail, Thunderbird).\n- Major webmail clients (Gmail, Outlook.com, Yahoo Mail).\n- Major mobile clients (iOS Mail, Android Gmail, Outlook Mobile).\n- Verify responsive design and correct rendering of all Unlayer components and custom branding.\n- Use tools like Email on Acid or Litmus for broader compatibility checks if available.\n- Document any rendering issues and address them by adjusting templates or Unlayer configurations.\n\nMANUAL TESTING REQUIRED: This task requires hands-on testing of all email templates created in Subtask 34.2 using the Unlayer editor. The testing must be performed across the full range of email clients specified above to ensure proper rendering in all environments.\n\nTesting procedure:\n1. Send test emails with each template to all specified email clients\n2. For each client, verify:\n   - All visual elements render correctly\n   - Responsive design functions properly on different screen sizes\n   - Custom branding elements appear as intended\n   - No layout breakage or formatting issues occur\n   - Links and buttons function correctly\n   - Images display properly with appropriate fallbacks\n\n3. If Litmus or Email on Acid is available, use these tools to perform automated checks across a wider range of clients\n\n4. Create a detailed testing report documenting:\n   - Which templates were tested\n   - Which clients/devices were used\n   - Screenshots of any rendering issues\n   - Description of each issue found\n   - Priority level of each issue\n\n5. For any issues discovered, return to the Unlayer editor to make necessary adjustments:\n   - Modify HTML/CSS as needed\n   - Test alternative component configurations\n   - Implement workarounds for problematic email clients\n\nThis task cannot be completed by AI assistance and requires manual verification by a team member with access to the various email clients and testing tools.\n</info added on 2025-05-08T07:24:58.491Z>\n<info added on 2025-05-10T11:59:11+08:00>\nBasic testing has been completed for the standard email templates. Test emails have been sent using the following templates:\n- Newsletter template\n- Announcement template\n- Marketing campaign template\n- Course enrollment template\n\nThe emails were tested in Gmail, Outlook.com, and Apple Mail on both desktop and mobile devices. All templates rendered correctly with proper responsive behavior. The template designs maintained brand consistency and all interactive elements (buttons, links) functioned as expected.\n\nComprehensive testing across all email clients listed in the original requirements will be scheduled as part of the Phase 3 optimization work, but the initial testing confirms that the templates are working correctly for the most common email clients used by our audience.\n</info added on 2025-05-10T11:59:11+08:00>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 34
        }
      ]
    },
    {
      "id": 35,
      "title": "Phase 2: Build Out Advanced Email Features & User Management",
      "description": "With the core infrastructure in place, this phase focuses on developing advanced email capabilities such as user segmentation, campaign management, detailed analytics, and user preference systems.",
      "details": "This phase will group tasks related to: User tagging and segmentation (Task 20), Campaign Management System (Task 22), comprehensive Email Webhook Processing for analytics (Task 24), Email Analytics Dashboard (Task 25), and User Email Preference Management (Task 26).",
      "testStrategy": "Verify completion of all sub-tasks. Advanced features should be functional and integrated.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement User Tagging and Segmentation (from Task 20)",
          "description": "Implement user tagging and segmentation for targeted emails. (Originally Task 20)",
          "details": "Original Task 20. \n1. Design database schema for user tags and segments\n2. Create API endpoints for tag management\n3. Implement tag assignment logic for users\n4. Develop predefined segments based on common criteria (enrollment, purchase, activity, preferences)\n5. Build filtering logic for combining tags and attributes\n6. Create segment preview and size estimation tools\n7. Implement batch operations for tag management.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 35
        },
        {
          "id": 2,
          "title": "Implement Campaign Management System (from Task 22)",
          "description": "Develop campaign management interface with scheduling, targeting, and automation. (Originally Task 22)",
          "details": "Original Task 22. Key features:\n1. Design campaign management UI (listing, filtering, status).\n2. Implement campaign creation workflow.\n3. Create recipient selection using segments/tags (from Subtask 35.1).\n4. Build scheduling with timezone support.\n5. Implement campaign preview/testing (using Unlayer templates from Task 34).\n6. Add campaign duplication.\n7. Develop automation for recurring emails.\n8. Consider A/B testing capabilities.\n9. Implement campaign status tracking.",
          "status": "pending",
          "dependencies": [
            "35.1"
          ],
          "parentTaskId": 35
        }
      ]
    },
    {
      "id": 36,
      "title": "Phase 3: Optimize, Finalize, and Document",
      "description": "This final phase involves refining existing integrations, optimizing performance, conducting comprehensive testing, training users, and creating all necessary documentation for the email system.",
      "details": "Key activities include: Refining Postmark API integration (Task 31.10), implementing performance optimizations (Task 31.11), training admin users on Unlayer (Subtask 32.4), and documenting the Unlayer template creation process (Subtask 32.5).",
      "testStrategy": "Verify completion of all sub-tasks. System should be performant, users trained, and documentation complete.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    }
  ]
}